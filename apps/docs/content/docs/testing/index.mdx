---
title: Testing Plugins
description: Unit and integration testing for plugins
---

Test plugins using `createLocalPluginRuntime`, which loads plugins directly without Module Federation overhead.

## Setup

Import the local plugin runtime from `every-plugin/testing`:

```typescript
import { createLocalPluginRuntime } from "every-plugin/testing";
import { describe, it, expect } from "vitest";
import TestPlugin from "../src/index";
```

## Basic Test Structure

Create a test suite with automatic type inference:

```typescript
import { describe, it, expect } from "vitest";
import { createLocalPluginRuntime } from "every-plugin/testing";
import TestPlugin from "../src/index";

describe("Test Plugin", () => {
  // Define plugin map with 'as const' for type inference
  const pluginMap = {
    "test-plugin": TestPlugin
  } as const;

  const runtime = createLocalPluginRuntime(
    {
      registry: {
        "test-plugin": {
          remoteUrl: "http://localhost:3999/remoteEntry.js",
          version: "0.0.1"
        }
      },
      secrets: {
        API_KEY: "test-api-key-value"
      }
    },
    pluginMap
  );

  it("should fetch single item", async () => {
    const { client } = await runtime.usePlugin("test-plugin", {
      secrets: { apiKey: "{{API_KEY}}" },
      variables: { baseUrl: "http://localhost:1337" }
    });

    const result = await client.getById({ id: "test-123" });

    expect(result).toHaveProperty("item");
    expect(result.item.externalId).toBe("test-123");
  });
});
```

<Callout>
**Always use `as const`** on plugin maps for automatic type inference in tests.
</Callout>

## Testing Procedures

### Single Item Fetch

```typescript
it("should fetch single item", async () => {
  const { client } = await runtime.usePlugin("test-plugin", {
    secrets: { apiKey: "{{API_KEY}}" },
    variables: { baseUrl: "http://localhost:1337" }
  });

  const result = await client.getById({ id: "test-123" });

  expect(result).toHaveProperty("item");
  expect(result.item?.externalId).toBe("test-123");
});
```

### Bulk Operations

```typescript
it("should fetch bulk items", async () => {
  const { client } = await runtime.usePlugin("test-plugin", {
    secrets: { apiKey: "{{API_KEY}}" },
    variables: { baseUrl: "http://localhost:1337" }
  });

  const result = await client.getBulk({ 
    ids: ["item-1", "item-2", "item-3"] 
  });

  expect(result).toHaveProperty("items");
  expect(result.items).toHaveLength(3);
  expect(result.items[0].externalId).toBe("item-1");
});
```

### Search Operations

```typescript
it("should search and return results", async () => {
  const { client } = await runtime.usePlugin("test-plugin", {
    secrets: { apiKey: "{{API_KEY}}" },
    variables: { baseUrl: "http://localhost:1337" }
  });

  const result = await client.search({ 
    query: "typescript",
    limit: 10
  });

  expect(result).toHaveProperty("items");
  expect(result.items.length).toBeGreaterThan(0);
  expect(result.items.length).toBeLessThanOrEqual(10);
});
```

## Testing Streaming

Test streaming procedures with async iteration:

```typescript
it("should stream items", async () => {
  const { client } = await runtime.usePlugin("test-plugin", {
    secrets: { apiKey: "{{API_KEY}}" },
    variables: { baseUrl: "http://localhost:1337" }
  });

  const stream = await client.streamItems({ 
    query: "test",
    limit: 5
  });

  const items = [];
  for await (const item of stream) {
    items.push(item);
    if (items.length >= 5) break;
  }

  expect(items.length).toBe(5);
  expect(items[0]).toHaveProperty("item");
});
```

### Testing with Effect Streams

```typescript
import { Stream, Effect } from "every-plugin/effect";

it("should stream with Effect", async () => {
  const { client } = await runtime.usePlugin("test-plugin", {
    secrets: { apiKey: "{{API_KEY}}" },
    variables: { baseUrl: "http://localhost:1337" }
  });

  const streamResult = await client.streamItems({ 
    query: "test",
    limit: 5
  });

  const items = await Effect.runPromise(
    Stream.fromAsyncIterable(streamResult, error => error).pipe(
      Stream.take(5),
      Stream.runCollect
    )
  );

  const itemArray = Array.from(items);
  expect(itemArray.length).toBe(5);
});
```

## Testing Error Handling

### Common Plugin Errors

```typescript
import { CommonPluginErrors } from "every-plugin";

it("should handle rate limit error", async () => {
  const { client } = await runtime.usePlugin("test-plugin", {
    secrets: { apiKey: "{{API_KEY}}" },
    variables: { baseUrl: "http://localhost:1337" }
  });

  try {
    await client.triggerRateLimit();
    fail("Should have thrown error");
  } catch (error: any) {
    expect(error.code).toBe("RATE_LIMITED");
    expect(error.data.retryAfter).toBe(60);
    expect(error.data.limitType).toBe("requests");
  }
});

it("should handle unauthorized error", async () => {
  const { client } = await runtime.usePlugin("test-plugin", {
    secrets: { apiKey: "invalid-key" },
    variables: { baseUrl: "http://localhost:1337" }
  });

  await expect(
    client.getData({ id: "test" })
  ).rejects.toMatchObject({
    code: "UNAUTHORIZED",
    data: {
      apiKeyProvided: true,
      authType: "apiKey"
    }
  });
});

it("should handle service unavailable", async () => {
  const { client } = await runtime.usePlugin("test-plugin", {
    secrets: { apiKey: "{{API_KEY}}" },
    variables: { baseUrl: "http://invalid-host" }
  });

  await expect(
    client.getData({ id: "test" })
  ).rejects.toMatchObject({
    code: "SERVICE_UNAVAILABLE",
    data: {
      retryAfter: expect.any(Number)
    }
  });
});
```

## Testing Router Access

Test HTTP mounting with oRPC handlers:

```typescript
import { OpenAPIHandler } from "@orpc/openapi/node";
import { createServer } from "node:http";

it("should work via OpenAPI handler", async () => {
  const result = await runtime.usePlugin("test-plugin", {
    secrets: { apiKey: "{{API_KEY}}" },
    variables: { baseUrl: "http://localhost:1337" }
  });

  const { router, initialized } = result;
  const handler = new OpenAPIHandler(router);

  // Start test server
  const port = 3888;
  const baseUrl = `http://localhost:${port}`;

  const server = createServer(async (req, res) => {
    const response = await handler.handle(req, res, {
      prefix: "/api",
      context: initialized.context
    });
    if (!response.matched) {
      res.statusCode = 404;
      res.end("Not Found");
    }
  });

  await new Promise<void>((resolve) => {
    server.listen(port, () => resolve());
  });

  // Test HTTP request
  const response = await fetch(`${baseUrl}/api/getById`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ id: "http-test-123" })
  });

  const data = await response.json();

  expect(data).toHaveProperty("item");
  expect(data.item.externalId).toBe("http-test-123");

  // Cleanup
  await new Promise<void>((resolve) => {
    server.close(() => resolve());
  });
});
```

## Testing with Mock Services

Mock external dependencies for isolated testing:

```typescript
// Create mock service
class MockApiService {
  async getData(id: string) {
    return {
      externalId: id,
      content: "mock-content",
      createdAt: new Date().toISOString()
    };
  }

  async *streamData(query: string) {
    for (let i = 0; i < 3; i++) {
      yield {
        externalId: `${query}_${i}`,
        content: `mock-content-${i}`,
        createdAt: new Date().toISOString()
      };
    }
  }
}

// Use in plugin
export default createPlugin({
  id: "test-plugin",
  // ... contract and config
  initialize: (config) => Effect.gen(function* () {
    const service = process.env.NODE_ENV === "test"
      ? new MockApiService()
      : new RealApiService(config.secrets.apiKey);
    
    return { service };
  }),
  // ... router
});
```

## Testing Background Tasks

Test plugins with background producers:

```typescript
it("should produce events in background", async () => {
  const { client } = await runtime.usePlugin("background-plugin", {
    secrets: { apiKey: "{{API_KEY}}" },
    variables: {
      baseUrl: "http://localhost:1337",
      backgroundEnabled: true,
      backgroundIntervalMs: 100,
      backgroundMaxItems: 5
    }
  });

  // Wait for background producer to generate events
  await new Promise(resolve => setTimeout(resolve, 1000));

  // Listen to background events
  const stream = await client.listenBackground({ maxResults: 3 });

  const events = [];
  for await (const event of stream) {
    events.push(event);
    if (events.length >= 3) break;
  }

  expect(events.length).toBe(3);
  expect(events[0].id).toMatch(/^bg-\d+$/);
});
```

## Integration Testing

Test multiple plugins working together:

```typescript
import { createLocalPluginRuntime } from "every-plugin/testing";
import SourcePlugin from "./source-plugin";
import TransformerPlugin from "./transformer-plugin";

describe("Plugin Integration", () => {
  const pluginMap = {
    "source": SourcePlugin,
    "transformer": TransformerPlugin
  } as const;

  const runtime = createLocalPluginRuntime(
    {
      registry: {
        "source": { remoteUrl: "", version: "1.0.0" },
        "transformer": { remoteUrl: "", version: "1.0.0" }
      },
      secrets: { API_KEY: "test-key" }
    },
    pluginMap
  );

  it("should process data through pipeline", async () => {
    const { client: source } = await runtime.usePlugin("source", {
      secrets: { apiKey: "{{API_KEY}}" }
    });

    const { client: transformer } = await runtime.usePlugin("transformer", {
      variables: { format: "json" }
    });

    // Fetch from source
    const sourceData = await source.getData({ id: "test" });

    // Transform data
    const transformed = await transformer.transform({
      data: sourceData.item
    });

    expect(transformed).toHaveProperty("formatted");
    expect(transformed.format).toBe("json");
  });
});
```

## Complete Test Suite Example

Full test suite for a plugin:

```typescript
import { describe, it, expect, beforeAll, afterAll } from "vitest";
import { createLocalPluginRuntime } from "every-plugin/testing";
import TestPlugin from "../src/index";

describe("Complete Plugin Test Suite", () => {
  const pluginMap = { "test-plugin": TestPlugin } as const;

  const runtime = createLocalPluginRuntime(
    {
      registry: {
        "test-plugin": {
          remoteUrl: "http://localhost:3999/remoteEntry.js",
          version: "0.0.1"
        }
      },
      secrets: { API_KEY: "test-api-key" }
    },
    pluginMap
  );

  const TEST_CONFIG = {
    secrets: { apiKey: "{{API_KEY}}" },
    variables: { baseUrl: "http://localhost:1337" }
  };

  describe("Basic Operations", () => {
    it("should initialize correctly", async () => {
      const result = await runtime.usePlugin("test-plugin", TEST_CONFIG);
      
      expect(result.metadata.id).toBe("test-plugin");
      expect(result.metadata.version).toBe("0.0.1");
    });

    it("should fetch by ID", async () => {
      const { client } = await runtime.usePlugin("test-plugin", TEST_CONFIG);
      const result = await client.getById({ id: "test-123" });
      
      expect(result.item?.externalId).toBe("test-123");
    });

    it("should handle bulk fetch", async () => {
      const { client } = await runtime.usePlugin("test-plugin", TEST_CONFIG);
      const result = await client.getBulk({ ids: ["1", "2", "3"] });
      
      expect(result.items).toHaveLength(3);
    });
  });

  describe("Streaming", () => {
    it("should stream items", async () => {
      const { client } = await runtime.usePlugin("test-plugin", TEST_CONFIG);
      const stream = await client.streamItems({ query: "test", limit: 5 });
      
      const items = [];
      for await (const item of stream) {
        items.push(item);
        if (items.length >= 5) break;
      }
      
      expect(items.length).toBe(5);
    });
  });

  describe("Error Handling", () => {
    it("should handle invalid ID", async () => {
      const { client } = await runtime.usePlugin("test-plugin", TEST_CONFIG);
      
      await expect(
        client.getById({ id: "" })
      ).rejects.toThrow();
    });

    it("should handle rate limits", async () => {
      const { client } = await runtime.usePlugin("test-plugin", TEST_CONFIG);
      
      try {
        await client.triggerRateLimit();
        fail("Should throw");
      } catch (error: any) {
        expect(error.code).toBe("RATE_LIMITED");
      }
    });
  });

  afterAll(async () => {
    await runtime.shutdown();
  });
});
```

## Best Practices

### ✅ Do This

```typescript
// Use descriptive test names
it("should return empty array when no results found", async () => {
  // ...
});

// Test error cases
it("should throw UNAUTHORIZED when API key is invalid", async () => {
  // ...
});

// Use beforeAll/afterAll for setup/cleanup
beforeAll(async () => {
  await setupTestEnvironment();
});

afterAll(async () => {
  await runtime.shutdown();
});

// Test with realistic data
const testData = {
  id: "real-looking-id-123",
  query: "realistic search query",
  limit: 10
};
```

### ❌ Don't Do This

```typescript
// Don't use vague test names
it("test 1", async () => {
  // What does this test?
});

// Don't forget error cases
it("should work", async () => {
  // Only testing happy path
});

// Don't leak resources
// Missing cleanup:
// afterAll(async () => {
//   await runtime.shutdown();
// });

// Don't use unrealistic test data
const testData = { id: "1", query: "a", limit: 999999 };
```

## Next Steps

<Cards>
  <Card title="Local Development" href="/docs/using-plugins/local-development">
    Develop plugins locally
  </Card>
  <Card title="Deployment" href="/docs/creating-plugins/deployment">
    Deploy to production
  </Card>
  <Card title="Recipes" href="/docs/recipes">
    Advanced patterns
  </Card>
</Cards>
