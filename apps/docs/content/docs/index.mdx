---
title: Introduction
---

**every-plugin** is a framework for building composable, type-safe plugin systems. It combines [Effect](https://effect.website/) for resource lifecycle management, [Module Federation](https://module-federation.io/) for remote loading, and [oRPC](https://orpc.io/) for type-safe contracts.

## Quick Example

```typescript
import { createPluginRuntime } from "every-plugin/runtime";

const runtime = createPluginRuntime({
  registry: {
    "data-source": {
      remoteUrl: "https://cdn.example.com/plugins/source/remoteEntry.js",
      version: "1.0.0"
    }
  },
  secrets: { API_KEY: "secret-value" }
});

// Get the client
const { client } = await runtime.usePlugin("data-source", {
  secrets: { apiKey: "{{API_KEY}}" },
  variables: { timeout: 30000 }
});

const result = await client.search({ query: "typescript", limit: 20 });
console.log(`Found ${result.items.length} items`);

await runtime.shutdown();
```

## Core Concepts

### Plugins are Type-Safe Contracts

Plugins define their interface using [oRPC](https://orpc.io/) procedures. The runtime ensures type safety from contract definition through to client calls:

```typescript
export default createPlugin({
  initialize: () => { /* setup resources, return context */ }
  contract: oc.router({
    getData: oc.procedure
      .input(z.object({ id: z.string() }))
      .output(DataSchema),
    streamItems: oc.procedure
      .input(QuerySchema)
      .output(eventIterator(ItemSchema))
  }),
  createRouter: (context) => { /* implement contract */ }
});

const { client } = await runtime.usePlugin("plugin-id", config);
const data = await client.getData({ id: "123" });
```

### Runtime Manages the Lifecycle

The runtime handles plugin loading ([Module Federation](https://module-federation.io/) or local imports), secret injection, initialization, and cleanup. Resources are managed automatically through [Effect](https://effect.website/):

```typescript
const runtime = createPluginRuntime({
  registry: { /* plugin definitions */ },
  secrets: { /* secret values */ }
});

// Runtime handles initialization, resource management, and cleanup
const result = await runtime.usePlugin("plugin-id", config);

// Cleanup happens automatically
await runtime.shutdown();
```

### Multiple Access Patterns from One Interface

`usePlugin()` returns an `EveryPlugin` with three ways to work with plugins:

```typescript
const { client, router, metadata } = await runtime.usePlugin(...);

// 1. Client - Direct typed procedure calls
const data = await client.getData({ id: "123" });

// 2. Router - Mount as HTTP endpoints
const handler = new OpenAPIHandler(router);

// 3. Streaming - Process continuous data
const stream = await client.streamItems({ query: "typescript" });
for await (const item of stream) {
  console.log(item);
}
```

### Local and Remote Plugins, Same API

Two deployment patterns with identical APIs:

```typescript
// Production - Remote plugins via Module Federation
const runtime = createPluginRuntime({
  registry: {
    "plugin-id": {
      remoteUrl: "https://cdn.example.com/remoteEntry.js",
      version: "1.0.0"
    }
  }
});

// Development/Testing - Local plugins
const runtime = createLocalPluginRuntime(
  { registry: {...} },
  { "plugin-id": PluginImplementation }
);

// Same API for both
const { client } = await runtime.usePlugin("plugin-id", config);
```

### Secret Management with Template Injection

Secrets are defined centrally and injected at runtime using template syntax:

```typescript
const runtime = createPluginRuntime({
  registry: { /* plugins */ },
  secrets: {
    API_KEY: process.env.API_KEY,
    DATABASE_URL: process.env.DATABASE_URL
  }
});

// Templates get replaced with actual values
const { client } = await runtime.usePlugin("plugin-id", {
  secrets: {
    apiKey: "{{API_KEY}}",      // Injected at runtime
    dbUrl: "{{DATABASE_URL}}"
  },
  variables: {
    timeout: 30000              // Regular values pass through
  }
});
```

### Plugins Can Be Sophisticated

Plugins aren't limited to simple API wrappers. With Effect's resource management, they can:

**Run Background Tasks** - Continuously poll APIs, process queues, or generate events:
```typescript
initialize: (config) => Effect.gen(function* () {
  const queue = yield* Queue.bounded(1000);
  
  // Background producer runs until plugin shuts down
  yield* Effect.forkScoped(
    Effect.gen(function* () {
      while (true) {
        const event = yield* fetchFromExternalAPI();
        yield* Queue.offer(queue, event);
        yield* Effect.sleep("1 second");
      }
    })
  );
  
  return { queue };
})
```

**Stream Data Continuously** - Process infinite streams with backpressure:
```typescript
streamEvents: handler(async function* () {
  // Stream from queue with automatic backpressure
  while (true) {
    const event = await Effect.runPromise(Queue.take(context.queue));
    yield event;
  }
})
```

**Compose into Pipelines** - Chain plugins together for complex workflows:
```typescript
// Source → Processor → Distributor
const { client: source } = await runtime.usePlugin("data-source", config);
const { client: processor } = await runtime.usePlugin("transformer", config);
const { client: distributor } = await runtime.usePlugin("webhook", config);

const rawData = await source.fetch({ query: "typescript" });
const transformed = await processor.transform({ items: rawData.items });
await distributor.send({ items: transformed.items });
```

**Mount as HTTP APIs** - Expose plugin procedures via OpenAPI or RPC:
```typescript
const { router } = await runtime.usePlugin("plugin-id", config);
const handler = new OpenAPIHandler(router);

// Now your plugin is an HTTP API
server.use('/api', handler.handle);
```

This flexibility means plugins can be:
- **Simple API clients** for basic integrations
- **Background processors** for continuous data ingestion
- **Stream transformers** for real-time data pipelines
- **HTTP services** exposed via OpenAPI
- **Job workers** in queue systems like BullMQ

All with the same type-safe contract interface, and easy to use with simple async/await.

## Architecture

<Mermaid
  chart="
graph TD
  A[Runtime] --> B[Plugin Registry]
  A --> C[Secret Management]
  A --> D[Module Federation]

  D --> E[Remote Plugin]
  E --> F[oRPC Contract]
  E --> G[Plugin Instance]

  G --> H[Initialize]
  H --> I[Create Router]
  I --> J[EveryPlugin]

  J --> K[Client Calls]
  J --> L[HTTP Mounting]
  J --> M[Streaming]

  classDef runtime fill:#2563eb,stroke:#1d4ed8,stroke-width:2px,color:#fff
  classDef system fill:#7c3aed,stroke:#6d28d9,stroke-width:2px,color:#fff
  classDef plugin fill:#059669,stroke:#047857,stroke-width:2px,color:#fff
  classDef access fill:#dc2626,stroke:#b91c1c,stroke-width:2px,color:#fff

  class A runtime
  class B,C,D system
  class E,F,G,H,I plugin
  class J,K,L,M access"
/>

## Getting Started

<Cards>
  <Card title="Quick Start" href="/docs/quick-start">
    Get running in 5 minutes
  </Card>
  <Card title="Creating Plugins" href="/docs/plugins">
    Build plugins with oRPC contracts
  </Card>
  <Card title="Using Plugins" href="/docs/runtime">
    Runtime patterns and recipes
  </Card>
  <Card title="Testing" href="/docs/testing">
    Test plugins with mock services
  </Card>
</Cards>
