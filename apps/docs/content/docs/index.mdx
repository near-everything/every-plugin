---
title: Introduction
description: Build composable, type-safe plugin systems with remote modules
---

**every-plugin** is a framework for building composable, type-safe plugin systems. It combines [Effect](https://effect.website/) for resource lifecycle management, [Module Federation](https://module-federation.io/) for remote module loading, and [oRPC](https://orpc.io/) for type-safe contracts.

## Why Remote Modules?

Traditional npm packages require publish/install/rebuild cycles. **every-plugin** uses Module Federation to load plugins at runtime:

```typescript
// No npm install needed - plugins loaded remotely
const runtime = createPluginRuntime({
  registry: {
    "data-source": {
      remote: "https://cdn.example.com/plugins/source/remoteEntry.js"
    }
  }
});

// Plugin code loads from CDN at runtime
const { createClient } = await runtime.usePlugin("data-source", {
  secrets: { apiKey: "{{API_KEY}}" }
});
```

**Benefits:**

- ðŸš€ **Deploy instantly** - Plugin updates available immediately to all consumers
- ðŸ“¦ **Zero conflicts** - Shared dependencies via Module Federation
- ðŸ”„ **Independent versioning** - No coordinated releases required
- âš¡ **No build cycles** - Just deploy and use

## Quick Example

```typescript
import { createPluginRuntime } from "every-plugin/runtime";

const runtime = createPluginRuntime({
  registry: {
    "data-source": {
      remote: "https://cdn.example.com/plugins/source/remoteEntry.js"
    }
  },
  secrets: { API_KEY: process.env.SOCIAL_API_KEY }
});

// Get typed client
const { createClient } = await runtime.usePlugin("data-source", {
  secrets: { apiKey: "{{API_KEY}}" },
  variables: { timeout: 30000 }
});

// Add context (e.g., authentication)
const client = createClient({ userId: "user-123", sessionId: "session-123" });

// Call procedures
const result = await client.search({ query: "typescript", limit: 20 });
console.log(`Found ${result.items.length} items`);

// Stream data
const stream = await client.streamPosts({ query: "realtime" });
for await (const post of stream) {
  console.log(post);
}

await runtime.shutdown();
```

## Core Concepts

### Plugins are Type-Safe Contracts

Plugins define their interface using [oRPC](https://orpc.io/) procedures. The runtime ensures type safety from contract definition through to client calls:

```typescript
export default createPlugin({
  contract: oc.router({
    getData: oc.route({ method: 'POST', path: '/getData' }) // for OpenAPI support
      .input(z.object({ id: z.string() }))
      .output(z.object({ data: z.string() })),
    
    streamItems: oc.route({ method: 'POST', path: '/stream' })
      .input(z.object({ query: z.string() }))
      .output(eventIterator(ItemSchema))
  }),
  
  createRouter: (context, builder) => ({
    getData: builder.getData.handler(async ({ input }) => {
      return await context.service.fetch(input.id);
    })
  })
});
```

### Runtime Manages Lifecycle

The runtime handles plugin loading ([Module Federation](https://module-federation.io/) or local imports), secret injection, initialization, and cleanup. Resources are managed automatically through Effect's [ManagedRuntime](https://effect.website/docs/runtime/#managedruntime):

```typescript
const runtime = createPluginRuntime({
  registry: { /* plugins */ },
  secrets: { /* secret values */ }
});

// Runtime handles initialization, resource management, and cleanup
const { router } = await runtime.usePlugin("plugin-id", config);

await runtime.shutdown(); // Automatic resource cleanup
```

### Multiple Access Patterns

`usePlugin()` returns an `EveryPlugin` with three ways to work with plugins:

```typescript
const { createClient, router, metadata } = await runtime.usePlugin("plugin-id", config);

// 1. Client - Direct procedure calls
const client = createClient();
const data = await client.getData({ id: "123" });

// 2. Router - Mount as HTTP endpoints
const handler = new OpenAPIHandler(router);

// 3. Streaming - Process continuous data
const stream = await client.streamItems({ query: "test" });
for await (const item of stream) {
  console.log(item);
}
```

### Module and Remote Loading

Unified API supports both direct imports and remote loading:

```typescript
import { createPluginRuntime } from "every-plugin/runtime";
import LocalPlugin from "./plugins/local-plugin";

// Both module and remote in one config
const runtime = createPluginRuntime({
  registry: {
    // Direct module import (dev/test) - types derived automatically
    "local-plugin": { module: LocalPlugin },
    
    // Remote URL (production)
    "remote-plugin": { remote: "https://cdn.example.com/remoteEntry.js" },
    
    // Both (module takes precedence for easy dev/prod switching)
    "hybrid-plugin": {
      module: LocalPlugin,
      remote: "https://cdn.example.com/remoteEntry.js"
    }
  }
});

// Identical API for all loading strategies
const { router } = await runtime.usePlugin("local-plugin", config);
```

### Secret Management

Template injection for runtime secrets:

```typescript
const runtime = createPluginRuntime({
  registry: { /* plugins */ },
  secrets: {
    API_KEY: process.env.API_KEY,
    DATABASE_URL: process.env.DATABASE_URL
  }
});

// Templates get replaced with actual values
const { router } = await runtime.usePlugin("plugin-id", {
  secrets: {
    apiKey: "{{API_KEY}}",      // Replaced at runtime
    dbUrl: "{{DATABASE_URL}}"
  },
  variables: {
    timeout: 30000              // Regular config values
  }
});
```

## Plugin Architecture

Every plugin follows a three-file structure:

```
plugins/your-plugin/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ contract.ts    # oRPC contract (API definition)
â”‚   â”œâ”€â”€ service.ts     # Plain class wrapping external API
â”‚   â””â”€â”€ index.ts       # Plugin implementation
â”œâ”€â”€ rspack.config.cjs  # Build config (uses EveryPluginDevServer)
â””â”€â”€ plugin.dev.ts      # Dev server configuration
```

<Callout type="info">
Build configuration is streamlined with `EveryPluginDevServer` which automatically handles Module Federation, shared dependencies, and TypeScript compilation. See [Creating Plugins](/docs/creating-plugins) for details.
</Callout>

<Accordions>
<Accordion title="See Example Structure">

```typescript
// contract.ts - Define your API
export const contract = oc.router({
  getData: oc.route({ method: 'POST', path: '/getData' })
    .input(z.object({ id: z.string() }))
    .output(z.object({ data: z.string() }))
});

// service.ts - Handlers use service
export class MyService {
  constructor(private apiKey: string) {}
  
  getData(id: string) {
    return Effect.tryPromise({
      try: async () => {
        const response = await fetch(`https://api.example.com/data/${id}`, {
          headers: { Authorization: `Bearer ${this.apiKey}` }
        });
        return response.json();
      },
      catch: (e: unknown) => new Error(`Failed: ${e}`)
    });
  }
}

// index.ts - Wire it together
export default createPlugin({
  // Plugin identifier comes from registry key, not an 'id' field here
  contract,
  variables: z.object({ timeout: z.number().default(30000) }),
  secrets: z.object({ apiKey: z.string() }),

  initialize: (config) => Effect.gen(function* () {
    const service = new MyService(config.secrets.apiKey);
    return { service };
  }),
  
  createRouter: (context, builder) => ({
    getData: builder.getData.handler(async ({ input }) => {
      const data = await Effect.runPromise(
        context.service.getData(input.id)
      );
      return { data };
    })
  })
});
```

</Accordion>
</Accordions>

## Getting Started

<Cards>
  <Card title="Quick Start" href="/docs/getting-started">
    Install and run in 5 minutes
  </Card>
  <Card title="Creating Plugins" href="/docs/creating-plugins">
    Build your first plugin
  </Card>
  <Card title="Using Plugins" href="/docs/using-plugins">
    Runtime patterns and usage
  </Card>
  <Card title="Testing" href="/docs/testing">
    Test plugins locally
  </Card>
</Cards>
