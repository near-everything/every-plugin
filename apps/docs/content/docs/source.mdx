---
title: Source Plugins
description: Create data fetching plugins with oRPC contracts and state management
---

## Source Plugin Concept

Source plugins fetch data from external APIs using [oRPC](https://orpc.io/) contracts for type safety. They support multiple procedures (getById, search, getBulk) and can be used with streaming for continuous data collection.

## Creating a Source Plugin

Source plugins are created by forking the source plugin template and implementing the required interface:

```bash
git clone https://github.com/your-org/source-plugin-template my-source-plugin
cd my-source-plugin
npm install
```

## Plugin Interface

Source plugins implement the `SourcePlugin` interface with oRPC contracts:

```typescript
import { call, implement } from "@orpc/server";
import {
  ConfigurationError,
  Effect,
  PluginExecutionError,
  PluginLoggerTag,
  type SourcePlugin,
} from "every-plugin";
import type { Contract } from "./schemas";
import { MySourceConfigSchema, StateSchema } from "./schemas";

export class MySourcePlugin implements SourcePlugin<Contract, typeof MySourceConfigSchema, typeof StateSchema> {
  readonly id = "my-source-plugin" as const;
  readonly type = "source" as const;
  readonly contract = contract;
  readonly configSchema = MySourceConfigSchema;
  readonly stateSchema = StateSchema;

  private client: ApiClient | null = null;

  initialize(config: MySourceConfig): Effect.Effect<void, ConfigurationError> {
    return Effect.gen(function* () {
      const logger = yield* PluginLoggerTag;
      
      this.client = new ApiClient({
        baseUrl: config.variables?.baseUrl || "https://api.example.com",
        apiKey: config.secrets.apiKey,
        timeout: config.variables?.timeout || 30000,
      });
      
      yield* logger.logInfo("Source plugin initialized");
    }).pipe(Effect.provide(this));
  }

  // Define which procedures support streaming
  isStreamable(procedureName: string): boolean {
    return procedureName === "search";
  }

  shutdown(): Effect.Effect<void, never> {
    return Effect.gen(function* () {
      if (this.client) {
        yield* Effect.promise(() => this.client!.disconnect());
        this.client = null;
      }
    }).pipe(Effect.provide(this));
  }
}
```

## oRPC Contract Definition

Define your API contract with multiple procedures:

```typescript
import { initORPC } from "@orpc/server";
import { z } from "zod";

const orpc = initORPC();

export const SourceItemSchema = z.object({
  externalId: z.string(),
  content: z.string(),
  contentType: z.string().optional(),
  createdAt: z.string().optional(),
  url: z.string().optional(),
  authors: z.array(z.object({
    username: z.string(),
    displayName: z.string().optional(),
  })).optional(),
  raw: z.any(),
});

export const StateSchema = z.object({
  cursor: z.string().optional(),
  pageNumber: z.number().optional(),
  lastProcessedId: z.string().optional(),
  nextPollMs: z.number().optional(), // For streaming timing control
});

export const contract = orpc.contract({
  getById: orpc.route({
    method: "POST",
    path: "/getById",
    summary: "Get a single item by ID",
  })
    .input(z.object({
      id: z.string().min(1),
    }))
    .output(z.object({
      item: SourceItemSchema.optional(),
    })),

  getBulk: orpc.route({
    method: "POST", 
    path: "/getBulk",
    summary: "Get multiple items by IDs",
  })
    .input(z.object({
      ids: z.array(z.string()).min(1),
    }))
    .output(z.object({
      items: z.array(SourceItemSchema),
    })),

  search: orpc.route({
    method: "POST",
    path: "/search", 
    summary: "Search for items with pagination",
  })
    .input(z.object({
      query: z.string().min(1),
      limit: z.number().optional(),
    }))
    .output(z.object({
      items: z.array(SourceItemSchema),
      nextState: StateSchema.optional(),
    })),
});
```

## Procedure Implementation

Implement each procedure using oRPC handlers:

```typescript
// Single item fetch
private getById = implement(this.contract).getById.handler(async ({ input }) => {
  if (!this.client) {
    throw new Error("Plugin not initialized");
  }

  const apiItem = await this.client.getById(input.id);
  
  return {
    item: apiItem ? this.transformToSourceItem(apiItem) : undefined,
  };
});

// Bulk item fetch
private getBulk = implement(this.contract).getBulk.handler(async ({ input }) => {
  if (!this.client) {
    throw new Error("Plugin not initialized");
  }

  const apiItems = await this.client.getBulk(input.ids);
  
  return {
    items: apiItems.map(item => this.transformToSourceItem(item)),
  };
});

// Searchable/streamable procedure with state management
private search = implement(this.contract).use(this.stateMiddleware).search.handler(async ({ input, context }) => {
  if (!this.client) {
    throw new Error("Plugin not initialized");
  }

  const state = context.state;
  const currentPage = state?.pageNumber || 1;
  
  const results = await this.client.search(input.query, {
    page: currentPage,
    limit: input.limit || 20,
    cursor: state?.cursor,
  });
  
  const items = results.items.map(item => this.transformToSourceItem(item));
  const hasMore = results.items.length === (input.limit || 20);
  
  return {
    items,
    nextState: hasMore ? {
      pageNumber: currentPage + 1,
      cursor: results.nextCursor,
      lastProcessedId: items[items.length - 1]?.externalId,
      nextPollMs: 10, // Fast polling for streaming
    } : undefined,
  };
});

private transformToSourceItem(apiItem: any) {
  return {
    externalId: apiItem.id,
    content: apiItem.text || apiItem.content,
    contentType: "post",
    createdAt: apiItem.timestamp || new Date().toISOString(),
    url: apiItem.url,
    authors: apiItem.authors?.map((author: any) => ({
      username: author.handle || author.username,
      displayName: author.name || author.displayName,
    })),
    raw: apiItem,
  };
}
```

## State Management for Streaming

State enables resumable operations and controls streaming timing:

```typescript
// State middleware for passing state to procedures
private stateMiddleware = implement(this.contract).$context<{ state?: State }>().middleware(async ({ context, next }) => {
  return next({
    context: {
      state: context.state
    }
  });
});

// State transitions in search procedure
private search = implement(this.contract).use(this.stateMiddleware).search.handler(async ({ input, context }) => {
  const state = context.state;
  
  // Handle different states for workflow phases
  if (!state) {
    // Initial state - start historical fetch
    return {
      items: [],
      nextState: {
        phase: "historical",
        jobId: `hist_${Date.now()}`,
        nextPollMs: 10, // Fast polling for streaming
      }
    };
  }
  
  // Continue based on current state
  switch (state.phase) {
    case "historical":
      // Fetch historical data
      const historicalItems = await this.fetchHistoricalData(input.query);
      return {
        items: historicalItems,
        nextState: {
          phase: "realtime",
          lastProcessedId: historicalItems[historicalItems.length - 1]?.externalId,
          nextPollMs: 10,
        }
      };
      
    case "realtime":
      // Fetch new items since last check
      const newItems = await this.fetchNewItems(input.query, state.lastProcessedId);
      return {
        items: newItems,
        nextState: {
          phase: "realtime",
          lastProcessedId: newItems.length > 0 ? newItems[newItems.length - 1].externalId : state.lastProcessedId,
          nextPollMs: newItems.length > 0 ? 10 : 30000, // Faster polling when active
        }
      };
  }
});
```

## Plugin Execution

Route procedure calls through the main execute method:

```typescript
execute(input: any): Effect.Effect<any, PluginExecutionError> {
  return Effect.gen(function* () {
    if (!this.client) {
      return yield* Effect.fail(
        new PluginExecutionError("Plugin not initialized", false)
      );
    }

    // Route based on procedure field
    switch (input.procedure) {
      case "getById":
        return yield* Effect.tryPromise({
          try: () => call(this.getById, input.input, { context: {} }),
          catch: (error) => new PluginExecutionError(`getById failed: ${error}`, true)
        });
        
      case "getBulk":
        return yield* Effect.tryPromise({
          try: () => call(this.getBulk, input.input, { context: {} }),
          catch: (error) => new PluginExecutionError(`getBulk failed: ${error}`, true)
        });
        
      case "search":
        return yield* Effect.tryPromise({
          try: () => call(this.search, input.input, {
            context: { state: input.state }
          }),
          catch: (error) => new PluginExecutionError(`search failed: ${error}`, true)
        });
        
      default:
        return yield* Effect.fail(
          new PluginExecutionError(`Unknown procedure: ${input.procedure}`, false)
        );
    }
  });
}
```

## Using Source Plugins

Execute specific procedures with discriminated union inputs:

```typescript
const runtime = createPluginRuntime({ registry, secrets });

// Execute getById procedure
const singleItem = await runtime.runPromise(
  Effect.gen(function* () {
    const pluginRuntime = yield* PluginRuntime;
    
    const plugin = yield* pluginRuntime.usePlugin("my-source", {
      secrets: {
        apiKey: "{{API_KEY}}",
      },
      variables: {
        timeout: 30000,
      },
    });
    
    return yield* pluginRuntime.executePlugin(plugin, {
      procedure: "getById",
      input: { id: "item-123" },
      state: null,
    });
  })
);

// Execute search procedure
const searchResults = await runtime.runPromise(
  Effect.gen(function* () {
    const pluginRuntime = yield* PluginRuntime;
    
    const plugin = yield* pluginRuntime.usePlugin("my-source", config);
    return yield* pluginRuntime.executePlugin(plugin, {
      procedure: "search",
      input: { query: "typescript", limit: 10 },
      state: null,
    });
  })
);
```

## Testing Source Plugins

Test individual procedures and streaming behavior:

```typescript
describe("Source Plugin", () => {
  it("should execute getById procedure", async () => {
    const result = await runtime.runPromise(
      Effect.gen(function* () {
        const pluginRuntime = yield* PluginRuntime;
        const plugin = yield* pluginRuntime.usePlugin("my-source", config);
        
        return yield* pluginRuntime.executePlugin(plugin, {
          procedure: "getById",
          input: { id: "test-id-123" },
          state: null,
        });
      })
    );

    expect(result.item).toBeDefined();
    expect(result.item.externalId).toBe("test-id-123");
  });

  it("should stream search procedure", async () => {
    const result = await runtime.runPromise(
      Effect.gen(function* () {
        const pluginRuntime = yield* PluginRuntime;

        const stream = yield* pluginRuntime.streamPlugin(
          "my-source",
          config,
          {
            procedure: "search",
            input: { query: "test query", limit: 10 },
            state: null,
          },
          {
            maxItems: 20,
            maxInvocations: 3,
          }
        );

        const items = yield* stream.pipe(Stream.runCollect);
        return Array.from(items);
      })
    );

    expect(result.length).toBeGreaterThan(0);
    expect(result.length).toBeLessThanOrEqual(20);
  });
});
```

## Next Steps

- [Streaming](./stream) - Enable continuous data processing
- [Creating Plugins](./plugin) - General plugin creation guide
- [Runtime API](./runtime) - Complete runtime reference
