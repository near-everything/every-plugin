---
title: Local Development
description: Develop plugins locally with module entries
---

For local development, monorepos, or testing, you can use module entries with `createPluginRuntime` to work with plugins directly without Module Federation overhead.

## Setup

Import plugins directly and use module entries:

```typescript
import { createPluginRuntime } from "every-plugin/runtime";
import DataSource from "./plugins/data-source";
import Transformer from "./plugins/transformer";
```

## Basic Usage

Create a runtime with module entries:

```typescript
const runtime = createPluginRuntime({
  registry: {
    "data-source": { module: DataSource },
    "transformer": { module: Transformer }
  },
  secrets: { API_KEY: "dev-key" }
});

// Get fully typed client with automatic type inference
const { client } = await runtime.usePlugin("data-source", {
  secrets: { apiKey: "{{API_KEY}}" },
  variables: { timeout: 30000 }
});

// Call procedures with full type safety
const result = await client.getData({ id: "123" });
```

<Callout>
Module entries provide automatic type inference from the plugin constructor. No module augmentation needed!
</Callout>

## Automatic Type Inference

Module entries automatically infer types from the plugin:

```typescript
import { createPluginRuntime } from "every-plugin/runtime";
import DataSource from "./plugins/data-source";
import Transformer from "./plugins/transformer";

const runtime = createPluginRuntime({
  registry: {
    "data-source": { module: DataSource },
    "transformer": { module: Transformer }
  },
  secrets: { API_KEY: "test" }
});

// Full type safety without manual bindings
const { client } = await runtime.usePlugin("data-source", config);
//                                         ^-- Autocomplete for "data-source" | "transformer"

const result = await client.getData({ id: "123" });
//                          ^-- Autocomplete for all procedures
```

**Benefits:**
- IDE autocomplete for plugin IDs and procedure names
- Type inference for config (variables/secrets)
- Compile-time validation of inputs/outputs
- Better refactoring support
- No module augmentation required

## When to Use

### ✅ Use Module Entries For:

- **Monorepo development** - Work with local plugin implementations
- **Unit testing** - Test plugins without Module Federation overhead
- **Integration testing** - Test plugin interactions locally
- **Development servers** - Run plugins from source during development
- **CI/CD pipelines** - Test before deploying
- **Hybrid setups** - Mix local and remote plugins in one runtime

### ⚠️ Use Remote Entries For:

- **Production** - Load plugins via Module Federation from CDN
- **Distributed systems** - Plugins deployed separately from runtime
- **Remote plugins** - Third-party plugins from external sources

## Development Workflow

<Steps>

### Create Plugin Locally

```typescript title="plugins/my-plugin/src/index.ts"
import { createPlugin } from "every-plugin";
import { Effect } from "every-plugin/effect";
import { z } from "every-plugin/zod";

export default createPlugin({
  contract: {
    getData: oc.route({ method: 'POST', path: '/getData' })
      .input(z.object({ id: z.string() }))
      .output(z.object({ data: z.string() }))
  },
  variables: z.object({ baseUrl: z.string() }),
  secrets: z.object({ apiKey: z.string() }),
  initialize: (config) => Effect.gen(function* () {
    const service = new MyService(config.secrets.apiKey);
    return { service };
  }),
  createRouter: (context, builder) => ({
    getData: builder.getData.handler(async ({ input }) => {
      const data = await Effect.runPromise(
        context.service.getData(input.id)
      );
      return { data };
    })
  })
});
```

### Test Locally

```typescript title="dev-server.ts"
import { createPluginRuntime } from "every-plugin/runtime";
import MyPlugin from "./plugins/my-plugin/src/index";

const runtime = createPluginRuntime({
  registry: {
    "my-plugin": { module: MyPlugin }
  },
  secrets: {
    API_KEY: process.env.DEV_API_KEY || "dev-key"
  }
});

const { client } = await runtime.usePlugin("my-plugin", {
  secrets: { apiKey: "{{API_KEY}}" },
  variables: { baseUrl: "http://localhost:8080" }
});

// Test your plugin
const result = await client.getData({ id: "test-123" });
console.log(result);

await runtime.shutdown();
```

### Deploy When Ready

Once tested locally, build and deploy:

```bash
cd plugins/my-plugin
bun run build
# Deploy dist/ to CDN
```

</Steps>

## Monorepo Example

Perfect for monorepos where plugins live alongside the main app:

```
my-app/
├── apps/
│   └── api/
│       └── src/
│           └── main.ts          # Uses createLocalPluginRuntime in dev
├── plugins/
│   ├── data-source/
│   │   └── src/index.ts
│   └── transformer/
│       └── src/index.ts
└── package.json
```

```typescript title="apps/api/src/main.ts"
import { createPluginRuntime } from "every-plugin/runtime";
import DataSource from "../../../plugins/data-source/src/index";
import Transformer from "../../../plugins/transformer/src/index";

const runtime = createPluginRuntime({
  registry: {
    "data-source": { module: DataSource },
    "transformer": { module: Transformer }
  },
  secrets: {
    API_KEY: process.env.API_KEY!
  }
});

// Use plugins locally during development
const { client: source } = await runtime.usePlugin("data-source", {
  secrets: { apiKey: "{{API_KEY}}" }
});

const { client: transformer } = await runtime.usePlugin("transformer", {
  variables: { format: "json" }
});

// Execute pipeline
const data = await source.fetch({ query: "test" });
const transformed = await transformer.transform({ items: data.items });
```

## Testing Example

Use in test files for comprehensive testing:

```typescript title="__tests__/plugin.test.ts"
import { describe, it, expect } from "vitest";
import { createPluginRuntime } from "every-plugin/runtime";
import MyPlugin from "../src/index";

describe("MyPlugin", () => {
  const runtime = createPluginRuntime({
    registry: {
      "my-plugin": { module: MyPlugin }
    },
    secrets: { API_KEY: "test-key" }
  });

  it("should fetch data correctly", async () => {
    const { client } = await runtime.usePlugin("my-plugin", {
      secrets: { apiKey: "{{API_KEY}}" },
      variables: { baseUrl: "http://localhost:1337" }
    });

    const result = await client.getData({ id: "test-123" });
    
    expect(result).toHaveProperty("data");
    expect(result.data).toBe("test-data");
  });
  
  it("should handle errors", async () => {
    const { client } = await runtime.usePlugin("my-plugin", {
      secrets: { apiKey: "invalid-key" },
      variables: { baseUrl: "http://localhost:1337" }
    });

    await expect(
      client.getData({ id: "invalid" })
    ).rejects.toThrow();
  });
});
```

## Environment-Specific Runtime

Switch between module and remote based on environment:

```typescript
import { createPluginRuntime } from "every-plugin/runtime";
import DevPlugin from "./plugins/my-plugin";

const isDev = process.env.NODE_ENV === "development";

const runtime = createPluginRuntime({
  registry: {
    "my-plugin": isDev
      ? { module: DevPlugin }
      : { remote: "https://cdn.example.com/my-plugin/remoteEntry.js" }
  },
  secrets: { API_KEY: process.env.API_KEY }
});

// Same API for both
const { client } = await runtime.usePlugin("my-plugin", config);
```

Or use hybrid approach with module precedence:

```typescript
import DevPlugin from "./plugins/my-plugin";

const runtime = createPluginRuntime({
  registry: {
    "my-plugin": {
      module: isDev ? DevPlugin : undefined,  // Module used in dev
      remote: "https://cdn.example.com/my-plugin/remoteEntry.js"  // Fallback
    }
  }
});
```

## Best Practices

### ✅ Do This

```typescript
// Use module entries for local development
const runtime = createPluginRuntime({
  registry: {
    "plugin-1": { module: Plugin1 },
    "plugin-2": { module: Plugin2 }
  }
});

// Test locally before deploying
const { client } = await runtime.usePlugin("plugin-1", config);
await client.testOperation();

// Use remote entries for production
if (process.env.NODE_ENV === "production") {
  runtime = createPluginRuntime({
    registry: {
      "plugin-1": { remote: "https://..." },
      "plugin-2": { remote: "https://..." }
    }
  });
}
```

### ❌ Don't Do This

```typescript
// Don't mix concerns
const runtime = createPluginRuntime({
  registry: {
    "plugin-1": { module: Plugin1 }  // Local in production!
  }
});

// Don't skip testing
// Just deploy without local testing

// Don't forget environment switching
const runtime = createPluginRuntime({
  registry: {
    "plugin-1": { module: DevPlugin }  // Always dev mode!
  }
});
```

## Next Steps

<Cards>
  <Card title="Testing" href="/docs/testing">
    Comprehensive testing guide
  </Card>
  <Card title="Deployment" href="/docs/creating-plugins/deployment">
    Deploy plugins to production
  </Card>
  <Card title="Recipes" href="/docs/recipes">
    Advanced patterns
  </Card>
</Cards>
