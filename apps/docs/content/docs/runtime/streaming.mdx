---
title: Streaming
description: Continuous data processing with source plugins
---

## Basic Streaming

Turn any source plugin into a continuous stream:

```typescript
import { Effect, Stream } from "effect";

const result = await runtime.runPromise(
  Effect.gen(function* () {
    const pluginRuntime = yield* PluginRuntime;

    // Create stream directly - no initialization needed
    const stream = yield* pluginRuntime.streamPlugin(
      "social-feed",
      {
        secrets: { apiKey: "{{SOCIAL_API_KEY}}" },
        variables: { timeout: 30000 }
      },
      {
        procedure: "search",
        input: { query: "typescript", limit: 20 },
        state: null
      },
      {
        maxItems: 1000,
        maxInvocations: 10,
        stopWhenEmpty: true
      }
    );

    // Process with Effect Stream operations
    const items = yield* stream.pipe(
      Stream.take(100),
      Stream.runCollect
    );
    
    return Array.from(items);
  })
);
```

## Stream Options

Control streaming behavior:

```typescript
interface StreamingOptions {
  maxItems?: number;        // Stop after N total items
  maxInvocations?: number;  // Stop after N plugin calls
  stopWhenEmpty?: boolean;  // Stop when plugin returns no items
  onStateChange?: (newState, items) => Effect.Effect<void>; // State persistence
}
```

## State Persistence

Save and resume stream state:

```typescript
const saveState = (state: any) =>
  Effect.sync(() => {
    if (state) {
      Bun.write('./stream-state.json', JSON.stringify(state, null, 2));
    }
  });

const loadState = () =>
  Effect.tryPromise(async () => {
    const file = Bun.file('./stream-state.json');
    return (await file.exists()) ? await file.json() : null;
  }).pipe(Effect.catchAll(() => Effect.succeed(null)));

const stream = yield* pluginRuntime.streamPlugin(
  "social-feed",
  config,
  {
    procedure: "search",
    input: { query: "typescript" },
    state: yield* loadState() // Resume from saved state
  },
  {
    maxItems: 1000,
    onStateChange: (newState, items) => 
      Effect.gen(function* () {
        console.log(`State: ${newState?.phase} (${items.length} items)`);
        yield* saveState(newState);
      })
  }
);
```

## Stream Processing

Process each item through another plugin:

```typescript
const processedResults = yield* Effect.gen(function* () {
  const pluginRuntime = yield* PluginRuntime;

  // Get processor plugin
  const processor = yield* pluginRuntime.usePlugin("content-processor", {
    secrets: { apiKey: "{{API_KEY}}" }
  });

  // Get source stream
  const stream = yield* pluginRuntime.streamPlugin("social-feed", config, input);

  // Process each item
  return yield* stream.pipe(
    Stream.mapEffect((item) =>
      pluginRuntime.executePlugin(processor, { items: [item] }).pipe(
        Effect.catchAll((error) => {
          console.error("Processing failed:", error);
          return Effect.succeed({ items: [] });
        })
      )
    ),
    Stream.flatMap((result) => Stream.fromIterable(result.items)),
    Stream.runCollect
  );
});
```

## Multiple Source Streams

Combine streams from different plugins:

```typescript
const combinedResults = yield* Effect.gen(function* () {
  const pluginRuntime = yield* PluginRuntime;

  // Create multiple streams
  const socialStream = yield* pluginRuntime.streamPlugin("social-feed", socialConfig, socialInput);
  const newsStream = yield* pluginRuntime.streamPlugin("news-api", newsConfig, newsInput);

  // Merge and process
  const mergedStream = Stream.merge(socialStream, newsStream);

  return yield* mergedStream.pipe(
    Stream.take(200),
    Stream.runCollect
  );
});
```

## State Management

Plugins control streaming through state:

```typescript
// Plugin returns state to control streaming
{
  items: [...],
  nextState: {
    phase: "realtime",
    cursor: "page_2", 
    nextPollMs: 1000 // Wait 1 second before next call
  }
}

// nextPollMs controls timing:
// - null: Stop streaming
// - undefined/0: No delay
// - number: Delay in milliseconds
```

## Batch Processing

Process items in batches for efficiency:

```typescript
const batchedResults = yield* stream.pipe(
  Stream.grouped(10), // Process in batches of 10
  Stream.mapEffect((batch) =>
    pluginRuntime.executePlugin(batchProcessor, {
      items: Array.from(batch)
    })
  ),
  Stream.flatMap((result) => Stream.fromIterable(result.items)),
  Stream.runCollect
);
```

## Real-time Processing

Continuous processing with periodic execution:

```typescript
import { Schedule } from "effect";

const continuousProcessing = Effect.gen(function* () {
  const pluginRuntime = yield* PluginRuntime;

  yield* Effect.repeat(
    Effect.gen(function* () {
      const stream = yield* pluginRuntime.streamPlugin(
        "news-feed", config, input, { maxItems: 50, stopWhenEmpty: true }
      );

      const newItems = yield* stream.pipe(Stream.runCollect);
      
      if (newItems.length > 0) {
        console.log(`Processed ${newItems.length} new items`);
        // Store or process items...
      }
    }),
    { schedule: Schedule.spaced("30 seconds") }
  );
});
```

Streaming automatically handles plugin state, pagination, and timing control.
