---
title: Advanced
description: Manual lifecycle control and advanced runtime patterns
---

## Manual Lifecycle Control

For advanced use cases requiring granular control over plugin lifecycle:

```typescript
const manualLifecycle = Effect.gen(function* () {
  const pluginRuntime = yield* PluginRuntime;
  
  // 1. Load plugin constructor from Module Federation URL
  const constructor = yield* pluginRuntime.loadPlugin("my-plugin");
  
  // 2. Create plugin instance
  const instance = yield* pluginRuntime.instantiatePlugin(constructor);
  
  // 3. Initialize with config and secrets
  const initialized = yield* pluginRuntime.initializePlugin(instance, config);
  
  // 4. Execute with validated input
  const output = yield* pluginRuntime.executePlugin(initialized, input);
  
  return output;
});
```

## Plugin Caching

The runtime automatically caches plugins by configuration hash:

```typescript
// These will use the same cached plugin instance
const plugin1 = yield* pluginRuntime.usePlugin("my-plugin", config);
const plugin2 = yield* pluginRuntime.usePlugin("my-plugin", config); // Same config = cached

// Different config = new instance
const plugin3 = yield* pluginRuntime.usePlugin("my-plugin", { 
  ...config, 
  variables: { ...config.variables, timeout: 60000 } 
});
```

## Custom Module Federation

Override default module federation behavior:

```typescript
const runtime = createPluginRuntime({
  registry: {
    "my-plugin": {
      remoteUrl: "https://cdn.example.com/plugins/my-plugin@1.0.0/remoteEntry.js",
      type: "source",
      version: "1.0.0"
    }
  },
  secrets: {},
  // Custom module federation options
  moduleFederation: {
    timeout: 30000,
    retries: 3
  }
});
```

## Plugin Validation

Plugins are validated at each lifecycle stage:

```typescript
// Load stage validation
const constructor = yield* pluginRuntime.loadPlugin("my-plugin").pipe(
  Effect.catchTag("PluginRuntimeError", (error) => {
    if (error.operation === "load-plugin") {
      console.error("Plugin not found in registry:", error.pluginId);
    }
    return Effect.fail(error);
  })
);

// Instantiation validation
const instance = yield* pluginRuntime.instantiatePlugin(constructor).pipe(
  Effect.catchTag("PluginRuntimeError", (error) => {
    if (error.operation === "instantiate-plugin") {
      console.error("Plugin constructor failed:", error.cause);
    }
    return Effect.fail(error);
  })
);

// Configuration validation
const initialized = yield* pluginRuntime.initializePlugin(instance, config).pipe(
  Effect.catchTag("PluginRuntimeError", (error) => {
    if (error.operation === "validate-config") {
      console.error("Invalid configuration:", error.cause);
    }
    return Effect.fail(error);
  })
);
```

## Custom Logger Integration

Provide custom logging implementation:

```typescript
import { PluginLogger } from "every-plugin";

const customLogger: PluginLogger = {
  logInfo: (message, context) => 
    Effect.sync(() => myLogger.info(message, context)),
  logWarning: (message, context) => 
    Effect.sync(() => myLogger.warn(message, context)),
  logError: (message, error, context) => 
    Effect.sync(() => myLogger.error(message, { error, ...context })),
  logDebug: (message, context) => 
    Effect.sync(() => myLogger.debug(message, context))
};

const runtime = createPluginRuntime({
  registry,
  secrets,
  logger: customLogger
});
```

## Plugin Registry Management

Dynamic registry updates:

```typescript
// Load registry from external source
const loadRegistry = async () => {
  const response = await fetch("https://api.example.com/plugins/registry");
  return response.json();
};

// Create runtime with dynamic registry
const runtime = createPluginRuntime({
  registry: await loadRegistry(),
  secrets: await loadSecrets()
});

// Registry can include metadata
const registry = {
  "my-plugin": {
    remoteUrl: "https://cdn.example.com/plugins/my-plugin/remoteEntry.js",
    type: "source",
    version: "1.2.0",
    description: "My custom plugin",
    tags: ["data", "api"],
    author: "My Organization"
  }
};
```

## Performance Monitoring

Monitor plugin performance:

```typescript
const monitoredExecution = Effect.gen(function* () {
  const pluginRuntime = yield* PluginRuntime;
  const startTime = Date.now();
  
  const plugin = yield* pluginRuntime.usePlugin("my-plugin", config);
  const loadTime = Date.now() - startTime;
  
  const execStart = Date.now();
  const result = yield* pluginRuntime.executePlugin(plugin, input);
  const execTime = Date.now() - execStart;
  
  console.log("Performance metrics:", {
    pluginId: "my-plugin",
    loadTime,
    execTime,
    itemCount: result.items?.length || 0
  });
  
  return result;
});
```

## Memory Management

Control memory usage in long-running applications:

```typescript
// Clear plugin cache periodically
const memoryManagement = Effect.gen(function* () {
  const pluginRuntime = yield* PluginRuntime;
  
  // Process data
  const result = yield* processData();
  
  // Clear cache to free memory
  yield* pluginRuntime.clearCache();
  
  return result;
});

// Monitor memory usage
const monitorMemory = () => {
  const usage = process.memoryUsage();
  console.log("Memory usage:", {
    rss: Math.round(usage.rss / 1024 / 1024) + "MB",
    heapUsed: Math.round(usage.heapUsed / 1024 / 1024) + "MB",
    heapTotal: Math.round(usage.heapTotal / 1024 / 1024) + "MB"
  });
};
```

## Plugin Shutdown

Manually shutdown specific plugins:

```typescript
const manualShutdown = Effect.gen(function* () {
  const pluginRuntime = yield* PluginRuntime;
  
  const plugin = yield* pluginRuntime.usePlugin("my-plugin", config);
  
  // Use plugin
  const result = yield* pluginRuntime.executePlugin(plugin, input);
  
  // Manual shutdown
  yield* pluginRuntime.shutdownPlugin(plugin);
  
  return result;
});
```

## Testing Utilities

Use testing helpers for unit tests:

```typescript
import { createTestPluginRuntime } from "every-plugin/testing";

const testRuntime = createTestPluginRuntime(
  {
    registry: {
      "test-plugin": {
        remoteUrl: "mock://test-plugin",
        type: "transformer",
        version: "1.0.0"
      }
    },
    secrets: { API_KEY: "test-key" }
  },
  {
    "test-plugin": TestPlugin // Mock plugin class
  }
);

// Use in tests
const result = await testRuntime.runPromise(
  Effect.gen(function* () {
    const pluginRuntime = yield* PluginRuntime;
    
    const plugin = yield* pluginRuntime.usePlugin("test-plugin", config);
    return yield* pluginRuntime.executePlugin(plugin, input);
  })
);
```

These advanced patterns provide fine-grained control over plugin lifecycle and runtime behavior.
