---
title: Basic Usage
description: Core runtime patterns for plugin execution
---

## Simple Plugin Execution

The most common pattern - load, configure, and execute:

```typescript
import { createPluginRuntime, PluginRuntime } from "every-plugin/runtime";
import { Effect } from "effect";

const runtime = createPluginRuntime({
  registry: {
    "data-processor": {
      remoteUrl: "https://cdn.example.com/plugins/processor/remoteEntry.js",
      type: "transformer",
      version: "1.0.0"
    }
  },
  secrets: { API_KEY: "secret-value" }
});

const result = await runtime.runPromise(
  Effect.gen(function* () {
    const pluginRuntime = yield* PluginRuntime;
    
    // usePlugin handles load + instantiate + initialize
    const plugin = yield* pluginRuntime.usePlugin("data-processor", {
      secrets: { apiKey: "{{API_KEY}}" },
      variables: { timeout: 30000, batchSize: 100 }
    });
    
    // Execute with validated input
    return yield* pluginRuntime.executePlugin(plugin, {
      items: ["data1", "data2", "data3"]
    });
  })
);
```

## Multiple Plugin Composition

Chain multiple plugins in a single workflow:

```typescript
const pipeline = Effect.gen(function* () {
  const pluginRuntime = yield* PluginRuntime;
  
  // Load plugins
  const sourcePlugin = yield* pluginRuntime.usePlugin("data-source", sourceConfig);
  const transformPlugin = yield* pluginRuntime.usePlugin("transformer", transformConfig);
  
  // Execute in sequence
  const rawData = yield* pluginRuntime.executePlugin(sourcePlugin, {
    procedure: "fetch",
    input: { query: "typescript" },
    state: null
  });
  
  const processedData = yield* pluginRuntime.executePlugin(transformPlugin, {
    items: rawData.items
  });
  
  return processedData;
});

const result = await runtime.runPromise(pipeline);
```

## Source Plugin Procedures

Source plugins expose multiple procedures via oRPC contracts:

```typescript
// Single item fetch
const item = yield* pluginRuntime.executePlugin(sourcePlugin, {
  procedure: "getById",
  input: { id: "item-123" },
  state: null
});

// Bulk fetch
const items = yield* pluginRuntime.executePlugin(sourcePlugin, {
  procedure: "getBulk", 
  input: { ids: ["item-1", "item-2", "item-3"] },
  state: null
});

// Search with pagination
const searchResults = yield* pluginRuntime.executePlugin(sourcePlugin, {
  procedure: "search",
  input: { query: "typescript", limit: 20 },
  state: null // Initial call
});

// Continue with returned state
const nextPage = yield* pluginRuntime.executePlugin(sourcePlugin, {
  procedure: "search",
  input: { query: "typescript", limit: 20 },
  state: searchResults.nextState // Resume from here
});
```

## Configuration Patterns

### Environment Variables

```typescript
const runtime = createPluginRuntime({
  registry: loadRegistry(),
  secrets: {
    API_KEY: process.env.API_KEY!,
    DATABASE_URL: process.env.DATABASE_URL!,
    WEBHOOK_SECRET: process.env.WEBHOOK_SECRET!
  }
});
```

### Dynamic Configuration

```typescript
const config = {
  secrets: {
    apiKey: "{{API_KEY}}", // Hydrated from secrets
    clientSecret: "{{CLIENT_SECRET}}"
  },
  variables: {
    baseUrl: "https://api.example.com",
    timeout: 30000,
    retryAttempts: 3
  }
};

const plugin = yield* pluginRuntime.usePlugin("my-plugin", config);
```

## Worker Integration

Perfect for job processing systems:

```typescript
import { Job } from "bullmq";

// Initialize once per worker
const runtime = createPluginRuntime({
  registry: await loadRegistry(),
  secrets: await loadSecrets()
});

// Job processor
const processJob = (job: Job) =>
  runtime.runPromise(
    Effect.gen(function* () {
      const pluginRuntime = yield* PluginRuntime;
      const { pluginId, config, input } = job.data;

      const plugin = yield* pluginRuntime.usePlugin(pluginId, config);
      return yield* pluginRuntime.executePlugin(plugin, input);
    })
  );

// Cleanup on shutdown
process.on("SIGTERM", async () => {
  await runtime.disposeRuntime();
});
```

## Resource Management

The runtime automatically handles cleanup:

```typescript
// Runtime manages:
// - Plugin module caching
// - Instance reuse where appropriate  
// - Automatic cleanup on dispose()
// - Resource leak prevention

await runtime.disposeRuntime(); // Clean shutdown
```

Always call `dispose()` when shutting down your application.
