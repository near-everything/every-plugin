---
title: Using Plugins
description: Runtime patterns and recipes for plugin usage
---

The runtime loads and executes plugins using [Effect](https://effect.website/) composition and [Module Federation](https://module-federation.io/). This guide provides patterns for common usage scenarios.

## Type Safety (Optional)

For IDE autocomplete and type inference, install plugins as dev dependencies and define type bindings:

```typescript
// Install plugin as dev dependency
// bun add -D @my-org/data-source-plugin

import type { PluginBinding } from "every-plugin";
import type DataSource from "@my-org/data-source-plugin";
import { createPluginRuntime } from "every-plugin/runtime";

// Define type bindings for all your plugins
type AppBindings = {
  "data-source": PluginBinding<typeof DataSource>;
};

const { runtime, PluginService } = createPluginRuntime<AppBindings>({
  registry: {
    "data-source": {
      remoteUrl: "https://cdn.example.com/plugins/source/remoteEntry.js",
      version: "1.0.0"
    }
  }
});
```

**Benefits:**
- Plugin ID autocomplete in `usePlugin()`
- Config type inference (variables/secrets)
- Fully typed client procedure calls

Type bindings are completely optional - they just enhance your development experience.

## Type Extraction with EveryPlugin.Infer

Extract plugin types from runtime instances using `EveryPlugin.Infer`. This is useful for middleware, utilities, and type annotations:

```typescript
import type { PluginBinding, EveryPlugin } from "every-plugin";
import type DataSource from "@my-org/data-source-plugin";
import { createPluginRuntime } from "every-plugin/runtime";

type AppBindings = {
  "data-source": PluginBinding<typeof DataSource>;
};

const runtime = createPluginRuntime<AppBindings>({
  registry: {
    "data-source": {
      remoteUrl: "https://cdn.example.com/plugins/source/remoteEntry.js",
      version: "1.0.0"
    }
  }
});

// Extract plugin type from runtime instance
type DataSourcePlugin = EveryPlugin.Infer<typeof runtime, "data-source">;

// Use in middleware or utilities
function logPluginMetadata(plugin: DataSourcePlugin) {
  console.log(`Plugin: ${plugin.metadata.pluginId} v${plugin.metadata.version}`);
}

// Use with plugin results
const result = await runtime.usePlugin("data-source", config);
logPluginMetadata(result);
```

**Benefits:**
- Extract types without manually recreating them
- Type-safe middleware and utility functions
- Works with any typed runtime instance
- Infers complete `EveryPlugin` structure

## Local Plugin Development

For local development, monorepos, or testing, use `createLocalPluginRuntime` to work with plugins directly without Module Federation. This automatically infers type bindings from your plugin map:

```typescript
import { createLocalPluginRuntime } from "every-plugin/testing";
import DataSource from "./plugins/data-source";
import Transformer from "./plugins/transformer";

// Define plugin map with 'as const' for type inference
const pluginMap = {
  "data-source": DataSource,
  "transformer": Transformer
} as const;

// Runtime automatically infers bindings from plugin map
const { runtime, PluginService } = createLocalPluginRuntime(
  {
    registry: {
      "data-source": {
        remoteUrl: "http://localhost:3000/remoteEntry.js", // Not used, but required
        version: "1.0.0"
      },
      "transformer": {
        remoteUrl: "http://localhost:3001/remoteEntry.js",
        version: "1.0.0"
      }
    },
    secrets: { API_KEY: "dev-key" }
  },
  pluginMap
);

// Get fully typed client
const { client } = await runtime.runPromise(
  Effect.gen(function* () {
    const pluginService = yield* PluginService;
    return yield* pluginService.usePlugin("data-source", {
      secrets: { apiKey: "{{API_KEY}}" },
      variables: { timeout: 30000 }
    });
  })
);

// Call procedures with full type safety
const result = await client.getData({ id: "123" });
```

**When to use `createLocalPluginRuntime`:**
- **Monorepo development** - Work with local plugin implementations
- **Unit testing** - Test plugins without Module Federation overhead
- **Integration testing** - Test plugin interactions locally
- **Development servers** - Run plugins from source during development

**When to use `createPluginRuntime`:**
- **Production** - Load plugins via Module Federation from CDN
- **Distributed systems** - Plugins deployed separately from runtime
- **Remote plugins** - Third-party plugins from external sources

Both runtimes share the same API, making it easy to switch between local development and production deployment.

## Basic Usage

Create a runtime and use plugins:

```typescript
import { createPluginRuntime } from "every-plugin/runtime";
import { Effect } from "every-plugin/effect";

const { runtime, PluginService } = createPluginRuntime({
  registry: {
    "data-source": {
      remoteUrl: "https://cdn.example.com/plugins/source/remoteEntry.js",
      version: "1.0.0"
    }
  },
  secrets: { API_KEY: "secret-value" }
});

// Get the client
const { client } = await runtime.runPromise(
  Effect.gen(function* () {
    const pluginService = yield* PluginService;
    
    return yield* pluginService.usePlugin("data-source", {
      secrets: { apiKey: "{{API_KEY}}" },
      variables: { timeout: 30000 }
    });
  })
);

// Call procedures with plain promises
const result = await client.getData({ id: "123" });

await runtime.disposeRuntime();
```

## usePlugin Returns EveryPlugin

`usePlugin()` returns an `EveryPlugin` object with multiple access patterns:

```typescript
const { client, router, metadata, initialized } = yield* pluginService.usePlugin(...);

// client - Call procedures as methods
const result = await client.getById({ id: "123" });
const posts = await client.search({ query: "typescript" });

// router - For HTTP mounting
import { OpenAPIHandler, RPCHandler } from "every-plugin/orpc";
const openApiHandler = new OpenAPIHandler(router);
const rpcHandler = new RPCHandler(router);

// metadata - Plugin information
console.log(metadata.pluginId, metadata.version);

// initialized - Full plugin state (advanced)
```

## Access Pattern Recipes

<Cards>
  <Card title="Direct Client Calls" href="/docs/runtime/patterns#client-calls">
    Call plugin procedures as methods
  </Card>
  <Card title="HTTP Mounting" href="/docs/runtime/patterns#http-mounting">
    Expose plugins via OpenAPI or RPC
  </Card>
  <Card title="Streaming" href="/docs/runtime/patterns#streaming">
    Process continuous data streams
  </Card>
  <Card title="Multiple Plugins" href="/docs/runtime/patterns#multiple-plugins">
    Compose plugin pipelines
  </Card>
</Cards>

## Key Concepts

### Runtime and PluginService

The `createPluginRuntime()` function returns two items:

- **`runtime`** - Effect's ManagedRuntime that executes Effects and manages resources
- **`PluginService`** - The plugin service (an Effect) that loads and manages plugins

```typescript
const { runtime, PluginService } = createPluginRuntime({...});

// runtime executes Effects
await runtime.runPromise(
  Effect.gen(function* () {
    // PluginService is the service you yield to access plugin operations
    const pluginService = yield* PluginService;
    return yield* pluginService.usePlugin(...);
  })
);
```

This is Effect's standard service pattern - `runtime` runs Effects, `PluginService` is the service being accessed.

### Import Through every-plugin

Always import Effect, oRPC, and Zod through `every-plugin`:

```typescript
import { Effect, Stream, Queue } from "every-plugin/effect";
import { oc, implement, eventIterator } from "every-plugin/orpc";
import { z } from "every-plugin/zod";
```

### Secret Hydration

Secrets use template syntax and are replaced at runtime:

```typescript
const config = {
  secrets: {
    apiKey: "{{API_KEY}}",      // Replaced with actual value
    dbUrl: "{{DATABASE_URL}}"
  },
  variables: {
    timeout: 30000              // Regular values pass through
  }
};
```

### Resource Cleanup

Always dispose the runtime when shutting down:

```typescript
process.on("SIGTERM", async () => {
  await runtime.disposeRuntime();
  process.exit(0);
});
```
