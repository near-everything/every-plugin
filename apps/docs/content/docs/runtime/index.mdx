---
title: Using Plugins
description: Runtime patterns and recipes for plugin usage
---

The runtime loads and executes plugins using [Effect](https://effect.website/) composition and [Module Federation](https://module-federation.io/). This guide provides patterns for common usage scenarios.

## Type Safety (Optional)

For IDE autocomplete and type inference, install plugins as dev dependencies and define type bindings:

```typescript
// Install plugin as dev dependency
// bun add -D @my-org/data-source-plugin

import type { PluginBinding } from "every-plugin";
import type DataSource from "@my-org/data-source-plugin";
import { createPluginRuntime } from "every-plugin/runtime";

// Define type bindings for all your plugins
type AppBindings = {
  "data-source": PluginBinding<typeof DataSource>;
};

const { runtime, PluginService } = createPluginRuntime<AppBindings>({
  registry: {
    "data-source": {
      remoteUrl: "https://cdn.example.com/plugins/source/remoteEntry.js",
      type: "source",
      version: "1.0.0"
    }
  }
});
```

**Benefits:**
- Plugin ID autocomplete in `usePlugin()`
- Config type inference (variables/secrets)
- Fully typed client procedure calls

Type bindings are completely optional - they just enhance your development experience.

## Basic Usage

Create a runtime and use plugins:

```typescript
import { createPluginRuntime } from "every-plugin/runtime";
import { Effect } from "every-plugin/effect";

const { runtime, PluginService } = createPluginRuntime({
  registry: {
    "data-source": {
      remoteUrl: "https://cdn.example.com/plugins/source/remoteEntry.js",
      type: "source",
      version: "1.0.0"
    }
  },
  secrets: { API_KEY: "secret-value" }
});

// Get the client
const { client } = await runtime.runPromise(
  Effect.gen(function* () {
    const pluginService = yield* PluginService;
    
    return yield* pluginService.usePlugin("data-source", {
      secrets: { apiKey: "{{API_KEY}}" },
      variables: { timeout: 30000 }
    });
  })
);

// Call procedures with plain promises
const result = await client.getData({ id: "123" });

await runtime.disposeRuntime();
```

## usePlugin Returns EveryPlugin

`usePlugin()` returns an `EveryPlugin` object with multiple access patterns:

```typescript
const { client, router, metadata, initialized } = yield* pluginService.usePlugin(...);

// client - Call procedures as methods
const result = await client.getById({ id: "123" });
const posts = await client.search({ query: "typescript" });

// router - For HTTP mounting
import { OpenAPIHandler, RPCHandler } from "every-plugin/orpc";
const openApiHandler = new OpenAPIHandler(router);
const rpcHandler = new RPCHandler(router);

// metadata - Plugin information
console.log(metadata.pluginId, metadata.version, metadata.type);

// initialized - Full plugin state (advanced)
```

## Access Pattern Recipes

<Cards>
  <Card title="Direct Client Calls" href="/docs/runtime/patterns#client-calls">
    Call plugin procedures as methods
  </Card>
  <Card title="HTTP Mounting" href="/docs/runtime/patterns#http-mounting">
    Expose plugins via OpenAPI or RPC
  </Card>
  <Card title="Streaming" href="/docs/runtime/patterns#streaming">
    Process continuous data streams
  </Card>
  <Card title="Multiple Plugins" href="/docs/runtime/patterns#multiple-plugins">
    Compose plugin pipelines
  </Card>
</Cards>

## Key Concepts

### Runtime and PluginService

The `createPluginRuntime()` function returns two items:

- **`runtime`** - Effect's ManagedRuntime that executes Effects and manages resources
- **`PluginService`** - The plugin service (an Effect) that loads and manages plugins

```typescript
const { runtime, PluginService } = createPluginRuntime({...});

// runtime executes Effects
await runtime.runPromise(
  Effect.gen(function* () {
    // PluginService is the service you yield to access plugin operations
    const pluginService = yield* PluginService;
    return yield* pluginService.usePlugin(...);
  })
);
```

This is Effect's standard service pattern - `runtime` runs Effects, `PluginService` is the service being accessed.

### Import Through every-plugin

Always import Effect, oRPC, and Zod through `every-plugin`:

```typescript
import { Effect, Stream, Queue } from "every-plugin/effect";
import { oc, implement, eventIterator } from "every-plugin/orpc";
import { z } from "every-plugin/zod";
```

### Secret Hydration

Secrets use template syntax and are replaced at runtime:

```typescript
const config = {
  secrets: {
    apiKey: "{{API_KEY}}",      // Replaced with actual value
    dbUrl: "{{DATABASE_URL}}"
  },
  variables: {
    timeout: 30000              // Regular values pass through
  }
};
```

### Resource Cleanup

Always dispose the runtime when shutting down:

```typescript
process.on("SIGTERM", async () => {
  await runtime.disposeRuntime();
  process.exit(0);
});
```

