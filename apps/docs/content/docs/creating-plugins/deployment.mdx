---
title: Plugin Deployment
description: Build and deploy plugins with Module Federation
---

Once your plugin is built, you need to deploy it to be accessible remotely.

## Building Your Plugin

The template uses `EveryPluginDevServer` which automatically handles all build configuration including Module Federation, shared dependencies, and TypeScript compilation.

### Development Build

Start the development server with hot reload:

```bash
bun run dev
```

This starts a dev server at `http://localhost:3014` (configurable in `plugin.dev.ts`) with:
- Hot module reloading
- Automatic TypeScript compilation via SWC
- Plugin mounted with `plugin.dev.ts` configuration
- CORS headers for remote testing
- Interactive API endpoints

<Callout type="tip">
Visit `http://localhost:3014/api` to access the **interactive Scalar API dashboard**. You can browse all endpoints, test procedures with live requests, and view schemas - all auto-generated from your oRPC contract. The better you document your contract (summaries, descriptions, tags), the better your API docs will be.
</Callout>

### Production Build

Build optimized production bundle:

```bash
bun run build
```

This generates:
- `dist/remoteEntry.js` - The Module Federation entry point
- `dist/*.js` - Code-split chunks for optimized loading
- `dist/**/*.js.map` - Source maps for debugging
- `dist/index.d.ts` - TypeScript definitions

## Deployment Options

The build output is a static bundle that can be deployed anywhere. Popular choices include:

- Static hosting (Netlify, Vercel, Cloudflare Pages)
- CDN services (AWS CloudFront, Cloudflare CDN)
- Object storage (AWS S3, Google Cloud Storage)
- Any web server serving static files

Simply deploy the `dist/` directory and access your plugin via:

```
https://your-domain.com/path-to-dist/remoteEntry.js
```

### Zephyr Cloud (Recommended)

The plugin template comes pre-configured with [Zephyr Cloud](https://zephyr-cloud.io/) for managed hosting:

```bash
bun run build
```

<Callout type="info">
Zephyr Cloud automatically handles versioning, CDN distribution, and provides analytics for your plugins.
</Callout>

## Plugin Registry

Once deployed, add your plugin to the runtime registry:

```typescript
const runtime = createPluginRuntime({
  registry: {
    "my-plugin": {
      remote: "https://cdn.example.com/plugins/my-plugin/v1.0.0/remoteEntry.js"
    }
  }
});
```

## Versioning Strategy

### Semantic Versioning

In order to take the best advantages of module federation and consistent updates, it is very important to follow semantic versioning for your plugins so changes do not break existing applications:

- **Major (1.0.0 → 2.0.0)** - Breaking contract changes
- **Minor (1.0.0 → 1.1.0)** - New procedures added
- **Patch (1.0.0 → 1.0.1)** - Bug fixes, no contract changes

### Deployment Pattern

```bash
# Deploy to versioned URL
https://cdn.example.com/plugins/my-plugin/v1.2.3/remoteEntry.js

# Also update "latest" pointer for consumers who want automatic updates
https://cdn.example.com/plugins/my-plugin/latest/remoteEntry.js
```

<Callout type="warning">
Breaking changes require a major version bump. Consumers must explicitly update their registry to use the new version.
</Callout>

## Publishing Types

Publish your plugin package to npm for type bindings:

```bash
# Build types
bun run build

# Publish to npm (types only, not runtime code)
bun publish --access public
```

Consumers install for types:

```bash
# Install as dev dependency for types
bun add -D @my-org/my-plugin
```

```typescript
// Import type-only
import type { MyPlugin } from "@my-org/my-plugin";

type AppBindings = {
  "my-plugin": typeof MyPlugin;
};
```

## Testing Before Deployment

Always test your plugin locally before deploying:

```typescript
import { createPluginRuntime } from "every-plugin/runtime";
import MyPlugin from "./src/index";

const runtime = createPluginRuntime({
  registry: {
    "my-plugin": { module: MyPlugin }
  },
  secrets: { API_KEY: "test-key" }
});

const { client } = await runtime.usePlugin("my-plugin", {
  secrets: { apiKey: "{{API_KEY}}" },
  variables: { baseUrl: "https://api.example.com" }
});

// Test your procedures
const result = await client.getData({ id: "test" });
console.log(result);

await runtime.shutdown();
```

## Deployment Checklist

Before deploying to production:

- [ ] All tests passing
- [ ] Contract procedures have input/output schemas
- [ ] Error paths tested with `CommonPluginErrors`
- [ ] Resources use `Effect.acquireRelease`
- [ ] Background tasks use `Effect.forkScoped`
- [ ] Secrets properly hydrated via `{{TEMPLATE}}`
- [ ] Build produces valid `remoteEntry.js`
- [ ] TypeScript types exported correctly
- [ ] Version number updated in `package.json`
- [ ] Plugin tested locally with module entries

## Troubleshooting

### Module Federation Errors

If you see "Shared module is not available":

```javascript
// Ensure shared dependencies match host app versions
shared: {
  "effect": {
    singleton: true,
    requiredVersion: "^3.10.0", // Match host app version
    strictVersion: false // Allow minor version differences
  }
}
```

### CORS Issues

If loading from CDN fails due to CORS:

```
# Add CORS headers to your CDN response
Access-Control-Allow-Origin: *
Access-Control-Allow-Methods: GET, OPTIONS
```

### Type Resolution

If types aren't resolving:

```json
// Ensure declaration is enabled in tsconfig.json
{
  "compilerOptions": {
    "declaration": true,
    "declarationMap": true
  }
}
```

## Next Steps

<Cards>
  <Card title="Testing" href="/docs/testing">
    Test your plugin locally
  </Card>
  <Card title="Using Plugins" href="/docs/using-plugins">
    Use plugins in your app
  </Card>
  <Card title="Recipes" href="/docs/recipes">
    Advanced patterns and examples
  </Card>
</Cards>
