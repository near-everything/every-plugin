---
title: Serverless Streaming
description: Serverless-ready event streams with resume support and metadata access
---

Design event streams that can resume after serverless timeouts using `lastEventId` and `resumeRetentionSeconds`:

```typescript
import { createPlugin } from "every-plugin";
import { Effect } from "every-plugin/effect";
import { oc, eventIterator, IORedisPublisher } from "every-plugin/orpc";
import { z } from "every-plugin/zod";

type ActivityEvents = {
  'user-activity': {
    id: string;
    userId: string;
    action: string;
    timestamp: number;
    metadata: Record<string, any>;
  };
};

const contract = oc.router({
  streamActivity: oc
    .route({ method: 'POST', path: '/stream/activity' })
    .input(z.object({
      userId: z.string().optional(),
      lastEventId: z.string().optional(),
      timeoutSec: z.number().default(300)
    }))
    .output(eventIterator(z.object({
      id: z.string(),
      userId: z.string(),
      action: z.string(),
      timestamp: z.number(),
      metadata: z.record(z.any())
    })))
});

export default createPlugin({
  contract,
  variables: z.object({
    redisUrl: z.string().optional(), // For multi-instance scaling
    resumeRetentionSeconds: z.number().default(300) // 5 minutes
  }),
  secrets: z.object({ activitySecret: z.string() }),

  initialize: (config) => Effect.gen(function* () {
    // Use Redis publisher for distributed deployments
    let publisher: any;
    if (config.variables.redisUrl) {
      const Redis = require('ioredis');
      const redis = new Redis(config.variables.redisUrl);
      publisher = new IORedisPublisher<ActivityEvents>(redis, {
        resumeRetentionSeconds: config.variables.resumeRetentionSeconds
      });
    } else {
      // Fallback to in-memory for development
      const { MemoryPublisher } = require('@orpc/experimental-publisher/memory');
      publisher = new MemoryPublisher<ActivityEvents>({
        resumeRetentionSeconds: config.variables.resumeRetentionSeconds
      });
    }

    // Background activity simulator
    yield* Effect.forkScoped(
      Effect.gen(function* () {
        let eventId = 0;
        while (true) {
          eventId++;
          const activity = {
            id: `activity-${eventId}`,
            userId: `user-${eventId % 100}`,
            action: ['login', 'click', 'purchase'][eventId % 3],
            timestamp: Date.now(),
            metadata: { sessionId: `session-${eventId}` }
          };

          yield* Effect.tryPromise(() =>
            publisher.publish('user-activity', activity)
          ).pipe(
            Effect.catchAll((error) => {
              console.log('Activity publish failed:', error);
              return Effect.void;
            })
          );

          yield* Effect.sleep("5 seconds");
        }
      })
    );

    return { publisher };
  }),

  createRouter: (context, builder) => ({
    streamActivity: builder.streamActivity.handler(async function* ({ input, signal }) {
      // Set up abort signal for timeout
      const controller = new AbortController();
      const timeoutId = setTimeout(() => {
        controller.abort();
      }, input.timeoutSec * 1000);

      signal?.addEventListener('abort', () => {
        clearTimeout(timeoutId);
        controller.abort();
      });

      try {
        const iterator = context.publisher.subscribe('user-activity', {
          signal,
          lastEventId: input.lastEventId
        });

        for await (const event of iterator) {
          // Filter by user if specified
          if (input.userId && event.userId !== input.userId) {
            continue;
          }

          // Check if timeout exceeded
          if (controller.signal.aborted) {
            break;
          }

          yield event;
        }
      } finally {
        clearTimeout(timeoutId);
      }
    })
  })
});
```

**Client-side Resume Logic:**

```typescript
// Client maintains lastEventId for resuming
let lastEventId: string | undefined;

async function streamActivities(config: any) {
  const { createClient } = await runtime.usePlugin("user-activity-stream");
  const client = createClient();

  while (true) {
    try {
      const stream = await client.streamActivity({
        lastEventId, // Resume from last received event
        timeoutSec: 300
      });

      for await (const event of stream) {
        console.log('Activity:', event);
        lastEventId = event.id; // Update last received

        // Process event...
        await processActivity(event);
      }

    } catch (error) {
      if (error.name === 'AbortError') {
        console.log('Stream timed out, resuming in 5 seconds...');
        await new Promise(resolve => setTimeout(resolve, 5000));
        continue; // Retry with lastEventId
      }

      throw error; // Non-timeout error
    }
  }
}
```

## Accessing Event Metadata

Event streams can include optional metadata for debugging, monitoring, and advanced use cases. Use `getEventMeta()` to access Server-Sent Events metadata from streaming responses:

```typescript
import { getEventMeta } from "every-plugin/orpc";

// In your streaming handler or consumer
for await (const event of stream) {
  // Access optional event metadata
  const meta = getEventMeta(event);

  // Metadata includes: id, retry, comments
  if (meta) {
    if (meta.id) console.log(`Event ID: ${meta.id}`);           // Correlation/tracking
    if (meta.retry) console.log(`Retry delay: ${meta.retry}ms`); // Connection health
    if (meta.comments?.length) console.log(`Comments: ${meta.comments}`);
  }

  // Process your event data
  console.log('Event data:', event);
}
```

**Metadata Fields:**
- **`id`**: Unique event identifier for correlation tracking and resume tokens
- **`retry`**: Milliseconds to wait before retrying if connection fails
- **`comments`**: Array of comment strings, often used for SSE debugging information

**Practical Use Cases:**

*Monitoring Connection Health:*
```typescript
const stream = await client.streamEvents({ lastEventId });

let lastEventTime = Date.now();
for await (const event of stream) {
  const meta = getEventMeta(event);

  if (meta?.id) {
    console.log(`[${new Date().toISOString()}] Event ${meta.id} received`);
    lastEventTime = Date.now();
  }

  // Monitor for stale connections
  const timeSinceLastEvent = Date.now() - lastEventTime;
  if (timeSinceLastEvent > 30000) { // 30 seconds
    console.warn('Stream appears stale, might need reconnection');
  }

  processEvent(event);
}
```

*Debugging Stream Quality:*
```typescript
let retryCount = 0;
const stream = await client.streamEvents();

for await (const event of stream) {
  const meta = getEventMeta(event);

  // Track retry rates as connection quality indicator
  if (meta?.retry && meta.retry > 1000) { // Slow retry suggests issues
    retryCount++;
    console.warn(`High retry delay detected: ${meta.retry}ms (count: ${retryCount})`);
  }

  // Log SSE comments for debugging
  if (meta?.comments?.length) {
    console.debug('SSE Comments:', meta.comments);
  }
}
```

**Note:** Metadata access is optional and primarily useful for debugging, monitoring, or advanced stream management. Most streaming use cases don't need to access these fields directly.

## Next Steps

<Cards>
  <Card title="Event Broadcasting" href="/docs/recipes/event-broadcasting">
    Basic event broadcasting patterns
  </Card>
  <Card title="Scaling" href="/docs/recipes/scaling">
    Scale across multiple instances
  </Card>
</Cards>
