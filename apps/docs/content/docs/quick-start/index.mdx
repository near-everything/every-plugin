---
title: Quick Start
description: Start building with every-plugin in 5 minutes
---

## Installation

```bash
bun add every-plugin
```


## Getting Started

Here's a complete example using a data source plugin:

```typescript
import { createPluginRuntime } from "every-plugin/runtime";

// Create runtime with plugin registry
const runtime = createPluginRuntime({
  registry: {
    "social-feed": {
      remoteUrl: "https://cdn.example.com/plugins/social/remoteEntry.js",
      version: "1.0.0"
    }
  },
  secrets: {
    API_KEY: process.env.SOCIAL_API_KEY!
  }
});

// Get the plugin client
const { client } = await runtime.usePlugin("social-feed", {
  secrets: { apiKey: "{{API_KEY}}" },
  variables: { timeout: 30000 }
});

// Call plugin procedures
const posts = await client.search({ query: "typescript", limit: 10 });
console.log(`Found ${posts.items.length} posts`);

// Always cleanup
await runtime.shutdown();
```

## Understanding usePlugin

`usePlugin()` returns an `EveryPlugin` object with everything you need:

```typescript
const { client, router, metadata, initialized } = await runtime.usePlugin("plugin-id", config);

// client - Call procedures as methods
const result = await client.getById({ id: "123" });
const posts = await client.search({ query: "typescript" });

// router - Mount in HTTP frameworks
import { OpenAPIHandler } from "every-plugin/orpc";
const handler = new OpenAPIHandler(router);

// metadata - Plugin information
console.log(metadata.pluginId, metadata.version);

// initialized - Full plugin state (advanced usage)
```

## Streaming Example

Streaming procedures return async iterables. You can use them directly or convert to Effect.Stream:

<Tabs items={['Streaming', 'with Effect']}>
  <Tab value="Streaming">
  ```typescript
  // Get the client
  const { client } = await runtime.usePlugin("social-feed", config);
  
  // Streaming procedures return async iterables
  const stream = await client.listenFeed({ query: "typescript" });
  
  // Use with for-await
  for await (const post of stream) {
    console.log(`Processing: ${post.item.externalId}`);
  }
  ```
  </Tab>
  <Tab value="with Effect">
  ```typescript
  import { Stream } from "every-plugin/effect";
  
  const result = await runtime.runPromise(
    Effect.gen(function* () {
      const pluginService = yield* PluginService;
      const { client } = yield* pluginService.usePlugin("social-feed", config);
      
      // Get async iterable
      const streamResult = await client.listenFeed({ query: "typescript" });
      
      // Convert to Effect Stream for Effect-based processing
      const stream = Stream.fromAsyncIterable(streamResult, error => error);
      
      // Process with Effect operators
      const items = yield* stream.pipe(
        Stream.take(50),
        Stream.runCollect
      );
      
      return Array.from(items);
    })
  );
  
  console.log(`Streamed ${result.length} items`);
  ```
  </Tab>
</Tabs>


## Type Safety (Optional)

For IDE autocomplete and type safety, install plugins as dev dependencies and define type bindings:

```typescript
// Install plugin as dev dependency
// bun add -D @my-org/social-feed-plugin

import type { PluginBinding } from "every-plugin";
import type SocialFeed from "@my-org/social-feed-plugin";
import { createPluginRuntime } from "every-plugin/runtime";

// Define type bindings for autocomplete and type inference
type AppBindings = {
  "social-feed": PluginBinding<typeof SocialFeed>;
};

// Pass bindings to runtime
const runtime = createPluginRuntime<AppBindings>({
  registry: {
    "social-feed": {...}
  }
});
```

**Benefits:**
- Plugin ID autocomplete in `usePlugin()`
- Config type inference (variables/secrets)
- Fully typed client procedure calls

Type bindings are completely optional - the framework works without them, but they provide a better development experience.

## Key Concepts

### Runtime

The `createPluginRuntime()` returns a `PluginRuntime` instance with a Promise-based API:

```typescript
const runtime = createPluginRuntime({
  registry: { /* plugin definitions */ },
  secrets: { /* secret values */ }
});

// Use plugins with simple Promise API
const { client } = await runtime.usePlugin("plugin-id", config);
```

### Error Handling

All runtime methods return Promises, so use try/catch:

```typescript
try {
  const { client } = await runtime.usePlugin("social-feed", config);
  const posts = await client.search({ query: "typescript" });
} catch (error) {
  console.error("Operation failed:", error);
}
```

### Secret Hydration

Secrets use template syntax and are replaced at runtime:

```typescript
const config = {
  secrets: {
    apiKey: "{{API_KEY}}",      // Replaced with actual value
    dbUrl: "{{DATABASE_URL}}"
  },
  variables: {
    timeout: 30000              // Regular values pass through
  }
};
```

### Import Through every-plugin

Always import dependencies through `every-plugin` for version consistency:

```typescript
import { Effect, Stream, Queue, Scope } from "every-plugin/effect";
import { oc, implement, eventIterator } from "every-plugin/orpc";
import { z } from "every-plugin/zod";
```

## Resource Cleanup

Always shutdown the runtime when done:

```typescript
// Graceful shutdown
process.on("SIGTERM", async () => {
  await runtime.shutdown();
  process.exit(0);
});
```
