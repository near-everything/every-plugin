---
title: Upgrading
description: Migration guides for major version changes
---

This guide covers breaking changes and migration steps for upgrading between major versions of every-plugin.

## v0.5 ‚Üí v0.6

Version 0.6.0 includes important bug fixes, template improvements, and updated build tooling for better compatibility.

### What's New

- üêõ **Module-Only Plugin Fix** - Plugins with direct module imports no longer error with undefined remote URLs
- üîß **Rspack 1.6.x Support** - Fixed Module Federation compatibility with rspack 1.6.x
- üì¶ **Simplified Template** - Merged tsconfig files, updated package.json exports
- üßπ **Cleaner Dependencies** - Removed unused dependencies (msw, sirv) from template

### Bug Fixes

#### 1. Module-Only Plugin Loading

Fixed an issue where plugins using `{ module: MyPlugin }` without a remote URL would crash with:
```
TypeError: undefined is not an object (evaluating 'url.endsWith')
```

**What Changed:**
- Added validation in `plugin-loader.service.ts` to check for remote URL before attempting Module Federation registration
- Direct module imports now properly skip remote loading entirely

**No migration needed** - this is a bug fix that improves existing functionality.

#### 2. Rspack 1.6.x Compatibility

Fixed a bundler compatibility issue in `module-federation.ts` that caused crashes with rspack 1.6.x:
```
TypeError: require_package$1.default is not a function
```

**What Changed:**
- Changed from `require('every-plugin/package.json')` to ESM `import` statement
- Fixes incorrect CommonJS interop code generated by tsdown/rolldown bundler

**No migration needed** - automatically works with both rspack 1.5.x and 1.6.x.

### Template Updates

The `plugins/_template` has been modernized with several improvements. If you're creating new plugins or want to update existing ones:

#### 1. Package.json Exports

**Before:**
```json
{
  "main": "./dist/index.js",
  "types": "./src/index.ts"
}
```

**After:**
```json
{
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "default": "./src/index.ts"
    }
  }
}
```

#### 2. Updated Dependencies

**Removed unused dependencies:**
- `msw` - Mock service worker (add if needed for your tests)
- `sirv` - Static file server (add if needed for dev server)

**Updated versions:**
- `@rspack/cli`: `^1.6.6` (was `^1.5.2`)
- `@rspack/core`: `^1.6.6` (was `^1.5.2`)

**Kept dependencies:**
- `@effect/language-service` - For Effect IDE support
- `dotenv` - For environment variables
- All other essential build and test dependencies

#### 3. Simplified TypeScript Config

**Before:** Two separate config files
- `tsconfig.json` - For IDE and tests
- `tsconfig.build.json` - For production builds

**After:** Single merged `tsconfig.json`
```json
{
  "compilerOptions": {
    "lib": ["ESNext"],
    "target": "ESNext",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "declaration": true,
    "declarationMap": true,
    // No rootDir or outDir - rspack handles output
    // ...other options
  },
  "files": ["tests/types.d.ts"],
  "include": ["src/**/*", "tests/**/*", "plugin.dev.ts"],
  "exclude": ["node_modules", "dist"]
}
```

**Why the change:**
- Rspack handles the build output structure, so `outDir`/`rootDir` aren't needed
- Single config is simpler and avoids conflicts
- TypeScript can now properly check all files including tests

#### 4. Updated Scripts

All useful scripts are now included:

```json
{
  "scripts": {
    "build": "rspack build",
    "dev": "rspack serve",
    "test": "vitest run",
    "test:watch": "vitest",
    "coverage": "vitest run --coverage",
    "typecheck": "tsc --noEmit"
  }
}
```

### Migration Steps for Plugin Authors

#### If Creating a New Plugin

Use the updated template - it already includes all improvements.

#### If Updating an Existing Plugin

**Step 1: Update package.json**

```bash
# Update rspack
bun add -D @rspack/cli@^1.6.6 @rspack/core@^1.6.6

# Optional: Remove unused deps if you don't need them
bun remove msw sirv
```

Update your `package.json` exports:
```json
{
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "default": "./src/index.ts"
    }
  },
  "scripts": {
    "build": "rspack build",
    "dev": "rspack serve",
    "test": "vitest run",
    "test:watch": "vitest",
    "coverage": "vitest run --coverage",
    "typecheck": "tsc --noEmit"
  }
}
```

**Step 2: Simplify TypeScript Config (Optional)**

Merge your `tsconfig.build.json` into `tsconfig.json`:

```json
{
  "compilerOptions": {
    "lib": ["ESNext"],
    "target": "ESNext",
    "module": "ESNext",
    "moduleDetection": "force",
    "jsx": "react-jsx",
    "allowJs": true,
    "moduleResolution": "bundler",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedIndexedAccess": true,
    "noImplicitOverride": true,
    "declaration": true,
    "declarationMap": true,
    "plugins": [{ "name": "@effect/language-service" }],
    "paths": { "@/*": ["./src/*"] }
  },
  "files": ["tests/types.d.ts"],
  "include": ["src/**/*", "tests/**/*", "plugin.dev.ts"],
  "exclude": ["node_modules", "dist"]
}
```

Then delete `tsconfig.build.json`.

**Step 3: Test and Rebuild**

```bash
bun run typecheck  # Should pass without rootDir errors
bun run test       # Verify tests still work
bun run build      # Build with rspack 1.6.x
```

### Backwards Compatibility

- All existing plugins continue to work without changes
- The bug fixes are transparent improvements
- Template updates are optional for existing plugins

---

## v0.4 ‚Üí v0.5

Version 0.5.0 introduces a unified `createPluginRuntime` API that supports both module (direct imports) and remote (Module Federation) loading strategies with automatic type inference.

### What's New

- üîÑ **Unified API** - Single `createPluginRuntime` for both module and remote loading
- üéØ **Automatic Type Inference** - Types derived from `module` entries without augmentation
- üì¶ **Flexible Registry** - Mix module and remote entries in the same configuration
- üè∑Ô∏è **Simplified Fields** - `remoteUrl` ‚Üí `remote`, removed `version` field
- üîß **Enhanced EveryPlugin.Infer** - Now accepts runtime instances for better type inference

### Breaking Changes

#### 1. Registry Format Changes

**Before (v0.4):**
```typescript
const runtime = createPluginRuntime({
  registry: {
    "my-plugin": {
      remoteUrl: "https://cdn.example.com/my-plugin/remoteEntry.js",
      version: "1.0.0"
    }
  }
});
```

**After (v0.5):**
```typescript
const runtime = createPluginRuntime({
  registry: {
    "my-plugin": {
      remote: "https://cdn.example.com/my-plugin/remoteEntry.js"
    }
  }
});
```

**Changes:**
- `remoteUrl` renamed to `remote`
- `version` field removed (not needed for runtime behavior)
- Optional `description` field added for documentation

#### 2. Module Entries (New Feature)

You can now include plugins directly in the registry:

```typescript
import { createPluginRuntime } from "every-plugin/runtime";
import LocalPlugin from "./plugins/local-plugin";

const runtime = createPluginRuntime({
  registry: {
    // Direct module import - types inferred automatically
    "local-plugin": { module: LocalPlugin },
    
    // Remote plugin
    "remote-plugin": { remote: "https://cdn.example.com/remoteEntry.js" },
    
    // Both (module takes precedence)
    "hybrid": {
      module: LocalPlugin,
      remote: "https://cdn.example.com/remoteEntry.js"
    }
  }
});
```

**Benefits:**
- No module augmentation needed for local plugins
- Automatic type inference from constructor
- Easier testing and development

#### 3. createLocalPluginRuntime Deprecated

**Before (v0.4):**
```typescript
import { createLocalPluginRuntime } from "every-plugin/testing";
import MyPlugin from "./my-plugin";

const runtime = createLocalPluginRuntime(
  {
    registry: {
      "my-plugin": { remoteUrl: "", version: "1.0.0" }
    },
    secrets: { API_KEY: "test" }
  },
  { "my-plugin": MyPlugin } as const
);
```

**After (v0.5):**
```typescript
import { createPluginRuntime } from "every-plugin/runtime";
import MyPlugin from "./my-plugin";

const runtime = createPluginRuntime({
  registry: {
    "my-plugin": { module: MyPlugin }
  },
  secrets: { API_KEY: "test" }
});
```

**Note:** `createLocalPluginRuntime` still works but is deprecated. It now wraps `createPluginRuntime` internally.

#### 4. Enhanced Type Inference

**Before (v0.4):**
```typescript
import type { EveryPlugin } from "every-plugin";

type MyPluginType = EveryPlugin.Infer<"my-plugin">;
```

**After (v0.5):**
```typescript
import type { EveryPlugin } from "every-plugin";

// Option 1: Still works with module augmentation
type MyPluginType = EveryPlugin.Infer<"my-plugin">;

// Option 2: Infer from runtime instance (new!)
const runtime = createPluginRuntime({
  registry: {
    "my-plugin": { module: MyPlugin }
  }
});

type MyPluginType = EveryPlugin.Infer<"my-plugin", typeof runtime>;
```

The runtime-based inference is especially useful with module entries since types are automatically derived.

### Migration Steps

#### Step 1: Update Registry Format

Replace all `remoteUrl` with `remote` and remove `version`:

```typescript
// Before
const runtime = createPluginRuntime({
  registry: {
    "plugin-1": {
      remoteUrl: "https://cdn.example.com/plugin1/remoteEntry.js",
      version: "1.0.0"
    },
    "plugin-2": {
      remoteUrl: "https://cdn.example.com/plugin2/remoteEntry.js",
      version: "2.5.0"
    }
  }
});

// After
const runtime = createPluginRuntime({
  registry: {
    "plugin-1": {
      remote: "https://cdn.example.com/plugin1/remoteEntry.js"
    },
    "plugin-2": {
      remote: "https://cdn.example.com/plugin2/remoteEntry.js"
    }
  }
});
```

#### Step 2: Migrate createLocalPluginRuntime Calls

Replace `createLocalPluginRuntime` with `createPluginRuntime` using module entries:

```typescript
// Before
import { createLocalPluginRuntime } from "every-plugin/testing";
import Plugin1 from "./plugin1";
import Plugin2 from "./plugin2";

const runtime = createLocalPluginRuntime(
  {
    registry: {
      "plugin-1": { remoteUrl: "", version: "1.0.0" },
      "plugin-2": { remoteUrl: "", version: "1.0.0" }
    },
    secrets: { API_KEY: "test" }
  },
  {
    "plugin-1": Plugin1,
    "plugin-2": Plugin2
  } as const
);

// After
import { createPluginRuntime } from "every-plugin/runtime";
import Plugin1 from "./plugin1";
import Plugin2 from "./plugin2";

const runtime = createPluginRuntime({
  registry: {
    "plugin-1": { module: Plugin1 },
    "plugin-2": { module: Plugin2 }
  },
  secrets: { API_KEY: "test" }
});
```

#### Step 3: Update Type Inference (Optional)

If using module entries, you can remove module augmentation:

```typescript
// Before - Required module augmentation
import type Plugin1 from "./plugin1";

declare module "every-plugin" {
  interface RegisteredPlugins {
    "plugin-1": typeof Plugin1;
  }
}

const runtime = createPluginRuntime({
  registry: {
    "plugin-1": { remoteUrl: "...", version: "1.0.0" }
  }
});

type Plugin1Type = EveryPlugin.Infer<"plugin-1">;

// After - Automatic inference with module entries
import Plugin1 from "./plugin1";

const runtime = createPluginRuntime({
  registry: {
    "plugin-1": { module: Plugin1 }
  }
});

type Plugin1Type = EveryPlugin.Infer<"plugin-1", typeof runtime>;
```

**Note:** Module augmentation still works and is recommended for remote-only plugins.

#### Step 4: Update Tests

Update test files to use the new format:

```typescript
// Before
import { createLocalPluginRuntime } from "every-plugin/testing";
import TestPlugin from "../src/index";

const pluginMap = { "test-plugin": TestPlugin } as const;

const runtime = createLocalPluginRuntime(
  {
    registry: {
      "test-plugin": {
        remoteUrl: "http://localhost:3999/remoteEntry.js",
        version: "0.0.1"
      }
    }
  },
  pluginMap
);

// After
import { createPluginRuntime } from "every-plugin/runtime";
import TestPlugin from "../src/index";

const runtime = createPluginRuntime({
  registry: {
    "test-plugin": { module: TestPlugin }
  }
});
```

### Hybrid Development/Production Pattern

The unified API enables easy switching between development and production:

```typescript
import { createPluginRuntime } from "every-plugin/runtime";
import DevPlugin from "./plugins/my-plugin";

const isDev = process.env.NODE_ENV === "development";

const runtime = createPluginRuntime({
  registry: {
    "my-plugin": isDev
      ? { module: DevPlugin }
      : { remote: "https://cdn.example.com/my-plugin/remoteEntry.js" }
  },
  secrets: { API_KEY: process.env.API_KEY }
});
```

Or use both with module precedence:

```typescript
const runtime = createPluginRuntime({
  registry: {
    "my-plugin": {
      module: isDev ? DevPlugin : undefined,
      remote: "https://cdn.example.com/my-plugin/remoteEntry.js"
    }
  }
});
```

### Backwards Compatibility

- `createLocalPluginRuntime` still works (wraps `createPluginRuntime`)
- Module augmentation still works for type inference
- Existing remote-only runtimes continue working (just update field names)

---

## v0.3 ‚Üí v0.4

Version 0.4.0 introduces improved type safety and better organization patterns for applications using multiple plugins or entry points.

### What's New

- üèóÔ∏è **Module Augmentation** - Declare plugins for full type safety
- üìÇ **Multi-Plugin Pattern** - Shared plugin instances across files
- üîß **Type Inference** - `EveryPlugin.Infer<K>` for extracting plugin types
- üîó **Plugin Bindings** - Automatic type safety via static binding property

### Module Augmentation for Type Safety

Register your plugins for IDE autocomplete and compile-time type checking:

```typescript
// In types.ts or main.ts
import type DataSource from "@org/data-source";
import type Transformer from "@org/transformer";

declare module "every-plugin" {
  interface RegisteredPlugins {
    "data-source": typeof DataSource;
    "transformer": typeof Transformer;
  }
}

// Now you get full type safety!
const { client } = await runtime.usePlugin("data-source", config);
// client has autocomplete, config is type-checked, etc.
```

### Multi-Plugin Pattern (plugins.ts)

For applications with multiple entry points (main process + workers):

```typescript
// plugins.ts - Single source of truth for plugin instances
import type DataSource from "@org/data-source";
import { createPluginRuntime } from "every-plugin/runtime";

declare module "every-plugin" {
  interface RegisteredPlugins {
    "data-source": typeof DataSource;
  }
}

export const runtime = createPluginRuntime({
  registry: {
    "data-source": {
      remoteUrl: "https://cdn.example.com/remoteEntry.js",
      version: "1.0.0"
    }
  },
  secrets: {
    API_KEY: process.env.API_KEY!
  }
});

// Initialize plugin once at module load
const dataSource = await runtime.usePlugin("data-source", {
  secrets: { apiKey: "{{API_KEY}}" },
  variables: { timeout: 30000 }
});

export const plugins = {
  dataSource
};

// Remember to shutdown
if (typeof process !== 'undefined') {
  process.once('SIGTERM', () => runtime.shutdown().then(() => process.exit(0)));
  process.once('SIGINT', () => runtime.shutdown().then(() => process.exit(0)));
}
```

**Usage in main.ts:**
```typescript
import { plugins, runtime } from "./plugins";

const { client } = plugins.dataSource;  // Already initialized
const results = await client.processData({ input: data });
```

**Usage in workers:**
```typescript
import { plugins } from "./plugins";

const { client } = plugins.dataSource;  // Same instance as main.ts
const result = await client.workerTask(task.data);
```

### Type Inference with EveryPlugin.Infer

Extract complete plugin types for reuse:

```typescript
import type { EveryPlugin } from "every-plugin";

// Extract the full plugin type - client + router + metadata
type DataSourcePlugin = EveryPlugin.Infer<"data-source">;

function processPlugin(plugin: DataSourcePlugin) {
  // client, router, metadata all fully typed
  console.log(`Using ${plugin.metadata.id}`);
  const results = await plugin.client.getData({ id: "123" });
  return results;
}
```

### Automatic Plugin Bindings

Plugins now expose type binding information automatically:

```typescript
import DataSource from "@org/data-source";

// Access binding for type operations
type Binding = typeof DataSource.binding;
// { contract, variables, secrets, config, context }
```

### Migration Steps

#### 1. Add Module Augmentation

In your main application file or a dedicated `types.ts`:

```typescript
import type DataSource from "@org/data-source";
import type Transformer from "@org/transformer";

declare module "every-plugin" {
  interface RegisteredPlugins {
    "data-source": typeof DataSource;
    "transformer": typeof Transformer;
  }
}
```

#### 2. (Optional) Create plugins.ts

If you have multiple entry points, create a shared `plugins.ts`:

```typescript
import type DataSource from "@org/data-source";
import { createPluginRuntime } from "every-plugin/runtime";

declare module "every-plugin" {
  interface RegisteredPlugins {
    "data-source": typeof DataSource;
  }
}

export const runtime = createPluginRuntime({...});

// Initialize once
const dataSource = await runtime.usePlugin("data-source", config);
export const plugins = { dataSource };

// Remember to shutdown
if (typeof process !== 'undefined') {
  process.once('SIGTERM', () => runtime.shutdown().then(() => process.exit(0)));
  process.once('SIGINT', () => runtime.shutdown().then(() => process.exit(0)));
}
```

#### 3. Use Type Inference

Where you need plugin types for utilities:

```typescript
import type { EveryPlugin } from "every-plugin";

type PluginType = EveryPlugin.Infer<"my-plugin">;

function withPlugin(plugin: PluginType) {
  // Full type safety
}
```

---

*More upgrade guides will be added as new versions are released.*
