---
title: Type System
description: Plugin type system and schema validation
---

## Core Types

### Plugin Types

```typescript
type PluginType = "source" | "transformer" | "distributor";
```

### Plugin Interface

```typescript
interface Plugin<TContract, TConfigSchema, TStateSchema> {
  readonly id: string;
  readonly type: PluginType;
  readonly contract: TContract;
  readonly configSchema: TConfigSchema;
  readonly stateSchema: TStateSchema;
  readonly inputSchema: InputSchema<TContract, TStateSchema>;
  readonly outputSchema: OutputSchema<TContract, TStateSchema>;
}
```

## Configuration Types

### Config Schema Creation

```typescript
function createConfigSchema<V extends ZodTypeAny, S extends ZodTypeAny>(
  variablesSchema?: V,
  secretsSchema?: S
): ConfigSchema<V, S>

// Usage
const ConfigSchema = createConfigSchema(
  z.object({ timeout: z.number().default(30000) }), // variables
  z.object({ apiKey: z.string() })                  // secrets
);

type Config = z.infer<typeof ConfigSchema>;
// Result: { variables?: { timeout?: number }, secrets?: { apiKey: string } }
```

### State Schema Creation

```typescript
function createStateSchema<T extends ZodTypeAny>(
  pluginStateSchema: T
): StateSchema<T>

// Usage
const StateSchema = createStateSchema(
  z.object({
    cursor: z.string().optional(),
    phase: z.enum(["historical", "realtime"]).optional()
  })
).nullable();

type State = z.infer<typeof StateSchema>;
// Result: { cursor?: string, phase?: "historical" | "realtime", nextPollMs?: number | null } | null
```

## Contract Types

### oRPC Contract Structure

```typescript
// Contract definition
const contract = {
  procedureName: oc
    .input(InputSchema)
    .output(OutputSchema)
};

// Type extraction
type ContractInput<T> = T extends { input: ZodSchema<infer I> } ? I : never;
type ContractOutput<T> = T extends { output: ZodSchema<infer O> } ? O : never;
```

### Input Schema Generation

```typescript
function createPluginInputSchema<TContract, TStateSchema>(
  contract: TContract,
  stateSchema: TStateSchema
): DiscriminatedUnion<"procedure", ProcedureSchemas>

// Generated input type for source plugins:
type PluginInput = 
  | { procedure: "getById", input: { id: string }, state: null }
  | { procedure: "search", input: { query: string }, state: State | null };
```

### Output Schema Generation

```typescript
function createPluginOutputSchema<TContract, TStateSchema>(
  contract: TContract,
  stateSchema: TStateSchema
): Union<ProcedureOutputSchemas>

// Generated output type:
type PluginOutput = 
  | { item?: SourceItem }
  | { items: SourceItem[], nextState?: State };
```

## Data Schemas

### Standard Item Schema

```typescript
const ItemSchema = z.object({
  externalId: z.string(),
  content: z.string(),
  contentType: z.string().optional(),
  createdAt: z.string().datetime().optional(),
  url: z.string().url().optional(),
  authors: z.array(z.object({
    id: z.string().optional(),
    username: z.string().optional(),
    displayName: z.string().optional()
  })).optional(),
  raw: z.unknown() // Original API response
});

type Item = z.infer<typeof ItemSchema>;
```

### Validation Schemas

```typescript
// Input validation with transforms
const FlexibleInputSchema = z.object({
  query: z.string().trim().min(1),
  limit: z.coerce.number().min(1).max(1000).default(20),
  includeMetadata: z.coerce.boolean().default(false)
});

// Output validation with strict types
const StrictOutputSchema = z.object({
  items: z.array(ItemSchema),
  totalCount: z.number().min(0),
  nextCursor: z.string().optional()
});
```

## Runtime Types

### Plugin Lifecycle Types

```typescript
interface PluginConstructor {
  ctor: new () => Plugin<any, any, any>;
  metadata: {
    pluginId: string;
    version?: string;
    description?: string;
    type?: PluginType;
  };
}

interface PluginInstance<T extends Plugin<any, any, any>> {
  plugin: T;
  metadata: PluginConstructor["metadata"];
}

interface InitializedPlugin<T extends Plugin<any, any, any>> {
  plugin: T;
  metadata: PluginConstructor["metadata"];
  config: z.infer<T["configSchema"]>;
}
```

### Execution Types

```typescript
type PluginExecutionInput<T extends Plugin<any, any, any>> = 
  z.infer<T["inputSchema"]>;

type PluginExecutionOutput<T extends Plugin<any, any, any>> = 
  z.infer<T["outputSchema"]>;
```

## Error Types

### Structured Errors

```typescript
abstract class PluginError extends Error {
  abstract readonly code: string;
  abstract readonly retryable: boolean;
  
  constructor(
    message: string,
    public readonly cause?: unknown
  ) {
    super(message);
    this.name = this.constructor.name;
  }
}

class ConfigurationError extends PluginError {
  readonly code = "CONFIGURATION_ERROR";
  readonly retryable = false;
}

class PluginExecutionError extends PluginError {
  readonly code = "PLUGIN_EXECUTION_ERROR";
  
  constructor(
    message: string,
    public readonly retryable: boolean,
    cause?: unknown
  ) {
    super(message, cause);
  }
}

class PluginRuntimeError extends PluginError {
  readonly code = "PLUGIN_RUNTIME_ERROR";
  
  constructor(config: {
    pluginId?: string;
    operation?: string;
    cause?: unknown;
    retryable: boolean;
  }) {
    super(`Plugin runtime error: ${config.cause}`, config.cause);
    this.pluginId = config.pluginId;
    this.operation = config.operation;
    this.retryable = config.retryable;
  }
  
  readonly pluginId?: string;
  readonly operation?: string;
  readonly retryable: boolean;
}
```

## Type Guards

### Plugin Type Guards

```typescript
function isSourcePlugin<T extends Plugin<any, any, any>>(
  plugin: T
): plugin is T & { type: "source" } {
  return plugin.type === "source";
}

function isTransformerPlugin<T extends Plugin<any, any, any>>(
  plugin: T
): plugin is T & { type: "transformer" } {
  return plugin.type === "transformer";
}

function isDistributorPlugin<T extends Plugin<any, any, any>>(
  plugin: T
): plugin is T & { type: "distributor" } {
  return plugin.type === "distributor";
}
```

### Validation Utilities

```typescript
function validateConfig<T>(
  schema: ZodSchema<T>,
  config: unknown
): Effect<T, ConfigurationError> {
  return Effect.try({
    try: () => schema.parse(config),
    catch: (error) => new ConfigurationError(
      `Configuration validation failed: ${error}`
    )
  });
}

function validateInput<T>(
  schema: ZodSchema<T>,
  input: unknown
): Effect<T, PluginExecutionError> {
  return Effect.try({
    try: () => schema.parse(input),
    catch: (error) => new PluginExecutionError(
      `Input validation failed: ${error}`,
      false
    )
  });
}
```

## Advanced Types

### Generic Plugin Types

```typescript
// Extract contract types
type ExtractContractTypes<T> = T extends { contract: infer C }
  ? C extends Record<string, { input: ZodSchema<infer I>; output: ZodSchema<infer O> }>
    ? { [K in keyof C]: { input: I; output: O } }
    : never
  : never;

// Conditional state types
type PluginWithState<T> = T extends { stateSchema: ZodSchema<infer S> }
  ? T & { state: S }
  : T;

// Plugin registry inference
type InferPluginFromRegistry<R, K> = K extends keyof R
  ? R[K] extends { type: infer T }
    ? T extends PluginType
      ? Plugin<any, any, any> & { type: T }
      : Plugin<any, any, any>
    : Plugin<any, any, any>
  : never;
```

### Streaming Types

```typescript
interface StreamingOptions
