---
title: API Reference
description: Complete runtime API reference
---

## createPluginRuntime

Create a plugin runtime instance:

```typescript
function createPluginRuntime(config: PluginRuntimeConfig): ManagedRuntime
```

**Parameters:**
- `config.registry` - Plugin registry mapping IDs to metadata
- `config.secrets` - Secret values for template hydration
- `config.logger?` - Optional custom logger implementation

**Returns:** `ManagedRuntime` instance

## PluginRuntime Service

Access via `yield* PluginRuntime` in Effect workflows.

### usePlugin

Load, initialize, and cache a plugin:

```typescript
usePlugin<T>(pluginId: string, config: Config): Effect<InitializedPlugin<T>, PluginRuntimeError>
```

### executePlugin

Execute an initialized plugin:

```typescript
executePlugin<T>(plugin: InitializedPlugin<T>, input: Input): Effect<Output, PluginRuntimeError>
```

### streamPlugin

Create a stream from a source plugin:

```typescript
streamPlugin<T>(
  pluginId: string, 
  config: Config, 
  input: Input, 
  options?: StreamingOptions
): Effect<Stream<Item, PluginRuntimeError>, PluginRuntimeError>
```

### Manual Lifecycle Methods

For advanced control:

```typescript
loadPlugin(pluginId: string): Effect<PluginConstructor, PluginRuntimeError>
instantiatePlugin<T>(ctor: PluginConstructor): Effect<PluginInstance<T>, PluginRuntimeError>
initializePlugin<T>(instance: PluginInstance<T>, config: Config): Effect<InitializedPlugin<T>, PluginRuntimeError>
```

## Plugin Interface

```typescript
interface Plugin<TContract, TConfigSchema, TStateSchema> {
  readonly id: string;
  readonly type: PluginType;
  readonly contract: TContract;
  readonly configSchema: TConfigSchema;
  readonly stateSchema: TStateSchema;
  
  initialize(config?: Config): Effect<void, ConfigurationError>;
  shutdown(): Effect<void, never>;
  createRouter(): any; // oRPC router
  isStreamable(procedureName: string): boolean;
}
```

## SimplePlugin Base Class

```typescript
abstract class SimplePlugin<TContract, TConfigSchema, TStateSchema> 
  implements Plugin<TContract, TConfigSchema, TStateSchema> {
  
  abstract readonly id: string;
  abstract readonly type: PluginType;
  abstract readonly contract: TContract;
  abstract readonly configSchema: TConfigSchema;
  
  readonly stateSchema = z.null() as TStateSchema;
  
  initialize(config?: Config): Effect<void, ConfigurationError> {
    return Effect.void;
  }
  
  shutdown(): Effect<void, never> {
    return Effect.void;
  }
  
  abstract createRouter(): any;
  
  isStreamable(procedureName: string): boolean {
    // Auto-detects based on contract output schema
  }
}
```

## Configuration Schemas

### createConfigSchema

```typescript
function createConfigSchema<V, S>(
  variablesSchema?: V, 
  secretsSchema?: S
): ConfigSchema<V, S>
```

### createStateSchema

```typescript
function createStateSchema<T>(pluginStateSchema: T): StateSchema<T>
```

## Streaming Options

```typescript
interface StreamingOptions<TItem, TPluginState> {
  maxItems?: number;
  maxInvocations?: number;
  stopWhenEmpty?: boolean;
  onStateChange?: (newState: TPluginState, items: TItem[]) => Effect<void>;
}
```

## Error Types

### PluginRuntimeError

```typescript
class PluginRuntimeError extends Error {
  readonly pluginId?: string;
  readonly operation?: string;
  readonly retryable: boolean;
  readonly cause?: unknown;
}
```

### ConfigurationError

```typescript
class ConfigurationError extends Error {
  readonly retryable = false;
}
```

### PluginExecutionError

```typescript
class PluginExecutionError extends Error {
  readonly retryable: boolean;
}
```

## State Transitions

Utilities for functional state updates:

```typescript
const StateTransitions = {
  to: <T>(phase: string, updates?: Partial<T>) => (state: T): T,
  withPolling: <T>(delayMs: number) => (state: T): T,
  withError: <T>(errorMessage: string) => (state: T): T,
  update: <T>(updates: Partial<T>) => (state: T): T
};

const pipe = <T>(value: T, ...fns: Array<(val: T) => T>): T;
```

## Testing Utilities

### createTestPluginRuntime

```typescript
function createTestPluginRuntime(
  config: PluginRuntimeConfig,
  pluginMap: TestPluginMap
): ManagedRuntime
```

### TestPluginMap

```typescript
interface TestPluginMap {
  [pluginId: string]: new () => Plugin<any, any, any>;
}
```

## Plugin Registry Types

```typescript
interface PluginMetadata {
  remoteUrl: string;
  type?: PluginType;
  version?: string;
  description?: string;
}

interface PluginRegistry {
  [pluginId: string]: PluginMetadata;
}

type PluginType = "source" | "transformer" | "distributor";
```

## Logger Interface

```typescript
interface PluginLogger {
  logInfo(message: string, context?: unknown): Effect<void>;
  logWarning(message: string, context?: unknown): Effect<void>;
  logError(message: string, error?: unknown, context?: unknown): Effect<void>;
  logDebug(message: string, context?: unknown): Effect<void>;
}
```

## Runtime Configuration

```typescript
interface PluginRuntimeConfig {
  registry: PluginRegistry;
  secrets?: Record<string, string>;
  logger?: PluginLogger;
}
```

All methods return Effect types for composable error handling and resource management.
