---
title: Overview
description: Real-world implementation patterns and use cases
---

## Common Patterns

### Plugin Composition
All examples demonstrate how to compose multiple plugins using Effect patterns:

```typescript
const workflow = Effect.gen(function* () {
  const pluginRuntime = yield* PluginRuntime;
  
  // Load multiple plugins
  const sourcePlugin = yield* pluginRuntime.usePlugin("data-source", config);
  const processorPlugin = yield* pluginRuntime.usePlugin("processor", config);
  
  // Execute in sequence
  const rawData = yield* pluginRuntime.executePlugin(sourcePlugin, input);
  const processedData = yield* pluginRuntime.executePlugin(processorPlugin, rawData);
  
  return processedData;
});
```

### Error Handling
Production-ready error handling with fallbacks and retry logic:

```typescript
const resilientWorkflow = workflow.pipe(
  Effect.retry({ times: 3 }),
  Effect.catchAll((error) => {
    console.error("Workflow failed:", error);
    return Effect.succeed({ items: [] }); // Fallback
  })
);
```

### Resource Management
Proper cleanup and lifecycle management:

```typescript
// Always dispose runtime when shutting down
process.on("SIGTERM", async () => {
  await runtime.dispose();
  process.exit(0);
});
```

## Prerequisites

Before exploring examples, ensure you understand:

- [Core Concepts](/docs/core/concepts) - Effect, Module Federation, oRPC, Zod
- [Runtime Basics](/docs/runtime/basic-usage) - Plugin lifecycle and composition
- [Error Handling](/docs/runtime/error-handling) - Production error patterns

## Next Steps

Start with the Multi-Source Pipeline example to understand the fundamental patterns, then explore more specialized use cases based on your needs.
