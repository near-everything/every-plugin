---
title: Real-time Processing
description: Continuous streaming and real-time data processing
---

## Basic Real-time Stream

Process data continuously with state persistence:

```typescript
import { Effect, Stream, Schedule } from "effect";

const realTimeProcessor = Effect.gen(function* () {
  const pluginRuntime = yield* PluginRuntime;

  // State persistence helpers
  const saveState = (state: any) =>
    Effect.sync(() => {
      if (state) {
        Bun.write('./stream-state.json', JSON.stringify(state, null, 2));
      }
    });

  const loadState = () =>
    Effect.tryPromise(async () => {
      const file = Bun.file('./stream-state.json');
      return (await file.exists()) ? await file.json() : null;
    }).pipe(Effect.catchAll(() => Effect.succeed(null)));

  // Create continuous stream
  const stream = yield* pluginRuntime.streamPlugin(
    "news-feed",
    {
      secrets: { apiKey: "{{NEWS_API_KEY}}" },
      variables: { timeout: 30000 }
    },
    {
      procedure: "monitor",
      input: { keywords: ["breaking", "urgent", "alert"] },
      state: yield* loadState() // Resume from saved state
    },
    {
      maxItems: 1000,
      onStateChange: (newState, items) => 
        Effect.gen(function* () {
          console.log(`State: ${newState?.phase} (${items.length} items)`);
          yield* saveState(newState);
        })
    }
  );

  // Process each item immediately
  return yield* stream.pipe(
    Stream.mapEffect((item) =>
      Effect.gen(function* () {
        console.log(`Processing: ${item.title}`);
        
        // Immediate processing for urgent items
        if (item.urgency > 0.8) {
          yield* sendAlert(item);
        }
        
        // Store all items
        yield* storeItem(item);
        
        return item;
      }).pipe(
        Effect.catchAll((error) => {
          console.error("Item processing failed:", error);
          return Effect.succeed(null);
        })
      )
    ),
    Stream.filter((item) => item !== null),
    Stream.runCollect
  );
});

const sendAlert = (item: any) =>
  Effect.tryPromise({
    try: () => fetch("https://alerts.example.com/webhook", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ alert: item.title, urgency: item.urgency })
    }),
    catch: (error) => new Error(`Alert failed: ${error}`)
  });

const storeItem = (item: any) =>
  Effect.tryPromise({
    try: () => database.items.create({ data: item }),
    catch: (error) => new Error(`Storage failed: ${error}`)
  });
```

## Multi-Stream Processing

Combine multiple real-time sources:

```typescript
const multiStreamProcessor = Effect.gen(function* () {
  const pluginRuntime = yield* PluginRuntime;

  // Create multiple streams
  const newsStream = yield* pluginRuntime.streamPlugin(
    "news-api", newsConfig, newsInput, { maxItems: 500 }
  );

  const socialStream = yield* pluginRuntime.streamPlugin(
    "social-feed", socialConfig, socialInput, { maxItems: 500 }
  );

  const alertStream = yield* pluginRuntime.streamPlugin(
    "alert-monitor", alertConfig, alertInput, { maxItems: 200 }
  );

  // Merge streams with priority
  const prioritizedStream = Stream.merge(
    alertStream.pipe(Stream.map(item => ({ ...item, priority: "high" }))),
    Stream.merge(
      newsStream.pipe(Stream.map(item => ({ ...item, priority: "medium" }))),
      socialStream.pipe(Stream.map(item => ({ ...item, priority: "low" })))
    )
  );

  // Process by priority
  return yield* prioritizedStream.pipe(
    Stream.mapEffect((item) =>
      Effect.gen(function* () {
        const processor = item.priority === "high" ? urgentProcessor : normalProcessor;
        const plugin = yield* pluginRuntime.usePlugin(processor, processorConfig);
        
        return yield* pluginRuntime.executePlugin(plugin, { items: [item] });
      })
    ),
    Stream.flatMap((result) => Stream.fromIterable(result.items)),
    Stream.runCollect
  );
});
```

## Stream Processing Pipeline

Process streaming data through multiple plugins:

```typescript
const streamPipeline = Effect.gen(function* () {
  const pluginRuntime = yield* PluginRuntime;

  // Initialize processing plugins
  const filter = yield* pluginRuntime.usePlugin("content-filter", {
    variables: { minScore: 0.6, maxLength: 1000 }
  });

  const enricher = yield* pluginRuntime.usePlugin("content-enricher", {
    secrets: { apiKey: "{{ENRICHMENT_API_KEY}}" }
  });

  const classifier = yield* pluginRuntime.usePlugin("content-classifier", {
    variables: { categories: ["tech", "business", "politics", "other"] }
  });

  // Create source stream
  const sourceStream = yield* pluginRuntime.streamPlugin(
    "live-feed", config, input, { maxItems: 2000 }
  );

  // Process through pipeline
  const processedItems = yield* sourceStream.pipe(
    // Stage 1: Filter
    Stream.mapEffect((item) =>
      pluginRuntime.executePlugin(filter, { items: [item] }).pipe(
        Effect.map(result => result.items[0] || null),
        Effect.catchAll(() => Effect.succeed(null))
      )
    ),
    Stream.filter((item) => item !== null),

    // Stage 2: Enrich
    Stream.mapEffect((item) =>
      pluginRuntime.executePlugin(enricher, { items: [item] }).pipe(
        Effect.map(result => result.items[0] || item),
        Effect.catchAll(() => Effect.succeed(item))
      )
    ),

    // Stage 3: Classify
    Stream.mapEffect((item) =>
      pluginRuntime.executePlugin(classifier, { items: [item] }).pipe(
        Effect.map(result => result.items[0] || item),
        Effect.catchAll(() => Effect.succeed(item))
      )
    ),

    // Collect results
    Stream.runCollect
  );

  return Array.from(processedItems);
});
```

## Continuous Monitoring

Set up continuous monitoring with periodic execution:

```typescript
const continuousMonitor = Effect.gen(function* () {
  const pluginRuntime = yield* PluginRuntime;

  yield* Effect.repeat(
    Effect.gen(function* () {
      console.log("Starting monitoring cycle...");

      // Check multiple sources
      const sources = ["news-api", "social-feed", "alert-system"];
      
      const results = yield* Effect.all(
        sources.map(sourceId =>
          Effect.gen(function* () {
            const stream = yield* pluginRuntime.streamPlugin(
              sourceId, 
              getSourceConfig(sourceId),
              getSourceInput(sourceId),
              { maxItems: 100, stopWhenEmpty: true }
            );

            const items = yield* stream.pipe(Stream.runCollect);
            console.log(`${sourceId}: ${items.length} new items`);

            return { source: sourceId, items: Array.from(items) };
          }).pipe(
            Effect.catchAll((error) => {
              console.error(`${sourceId} failed:`, error);
              return Effect.succeed({ source: sourceId, items: [] });
            })
          )
        ),
        { concurrency: 3 }
      );

      // Process all collected items
      const allItems = results.flatMap(r => r.items);
      if (allItems.length > 0) {
        yield* processItems(allItems);
      }

      console.log(`Monitoring cycle completed: ${allItems.length} items processed`);
    }),
    { schedule: Schedule.spaced("30 seconds") }
  );
});

const processItems = (items: any[]) =>
  Effect.gen(function* () {
    const pluginRuntime = yield* PluginRuntime;
    
    // Batch process for efficiency
    const processor = yield* pluginRuntime.usePlugin("batch-processor", {
      variables: { batchSize: 50 }
    });

    const batches = [];
    for (let i = 0; i < items.length; i += 50) {
      batches.push(items.slice(i, i + 50));
    }

    yield* Effect.all(
      batches.map(batch =>
        pluginRuntime.executePlugin(processor, { items: batch }).pipe(
          Effect.catchAll((error) => {
            console.error("Batch processing failed:", error);
            return Effect.succeed({ processed: 0 });
          })
        )
      ),
      { concurrency: 2 }
    );
  });
```

## Real-time Analytics

Process streaming data for real-time analytics:

```typescript
const realTimeAnalytics = Effect.gen(function* () {
  const pluginRuntime = yield* PluginRuntime;
  
  // Metrics tracking
  let metrics = {
    totalItems: 0,
    itemsPerMinute: 0,
    lastMinuteCount: 0,
    categories: {} as Record<string, number>,
    startTime: Date.now()
  };

  // Update metrics every minute
  const metricsUpdater = Effect.repeat(
    Effect.sync(() => {
      metrics.itemsPerMinute = metrics.lastMinuteCount;
      metrics.lastMinuteCount = 0;
      
      console.log("Real-time metrics:", {
        total: metrics.totalItems,
        perMinute: metrics.itemsPerMinute,
        categories: metrics.categories,
        uptime: Math.round((Date.now() - metrics.startTime) / 1000 / 60) + "min"
      });
    }),
    { schedule: Schedule.spaced("1 minute") }
  ).pipe(Effect.fork);

  // Start metrics updater
  yield* metricsUpdater;

  // Process stream with analytics
  const stream = yield* pluginRuntime.streamPlugin(
    "analytics-feed", config, input, { maxItems: 5000 }
  );

  return yield* stream.pipe(
    Stream.mapEffect((item) =>
      Effect.gen(function* () {
        // Update metrics
        metrics.totalItems++;
        metrics.lastMinuteCount++;
        
        if (item.category) {
          metrics.categories[item.category] = (metrics.categories[item.category] || 0) + 1;
        }

        // Real-time processing
        if (item.score > 0.9) {
          yield* sendHighScoreAlert(item);
        }

        // Store for analytics
        yield* storeAnalyticsData(item);

        return item;
      }).pipe(
        Effect.catchAll((error) => {
          console.error("Analytics processing failed:", error);
          return Effect.succeed(item);
        })
      )
    ),
    Stream.runCollect
  );
});

const sendHighScoreAlert = (item: any) =>
  Effect.tryPromise({
    try: () => console.log(`High score alert: ${item.title} (${item.score})`),
    catch: () => new Error("Alert failed")
  });

const storeAnalyticsData = (item: any) =>
  Effect.tryPromise({
    try: () => analyticsDB.store(item),
    catch: () => new Error("Storage failed")
  });
```

## Graceful Shutdown

Handle shutdown gracefully in real-time systems:

```typescript
const gracefulRealTimeSystem = Effect.gen(function* () {
  const pluginRuntime = yield* PluginRuntime;
  
  // Track active streams
  const activeStreams = new Set<any>();
  
  // Shutdown handler
  const shutdown = Effect.gen(function* () {
    console.log("Shutting down real-time system...");
    
    // Stop all active streams
    for (const stream of activeStreams) {
      yield* Effect.tryPromise(() => stream.interrupt());
    }
    
    // Save final state
    yield* saveSystemState();
    
    console.log("Real-time system shutdown complete");
  });

  // Register shutdown handlers
  process.on("SIGTERM", () => Effect.runPromise(shutdown));
  process.on("SIGINT", () => Effect.runPromise(shutdown));

  // Start real-time processing
  const stream = yield* pluginRuntime.streamPlugin(
    "continuous-feed", config, input
  );
  
  activeStreams.add(stream);

  return yield* stream.pipe(
    Stream.mapEffect(processRealTimeItem),
    Stream.runCollect
  );
});

const saveSystemState = () =>
  Effect.tryPromise({
    try: () => Bun.write('./system-state.json', JSON.stringify({
      timestamp: new Date().toISOString(),
      metrics: metrics,
      status: "shutdown"
    })),
    catch: () => new Error("Failed to save system state")
  });
```

These patterns enable robust real-time data processing with state management and graceful error handling.
