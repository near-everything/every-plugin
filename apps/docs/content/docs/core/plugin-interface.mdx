---
title: Plugin Interface
description: Detailed specification of the plugin interface and implementation requirements
---

## Plugin Interface Overview

All plugins implement a common interface that defines their structure, lifecycle, and execution contract. The interface ensures type safety, consistent behavior, and proper resource management across all plugin types.

```typescript
interface Plugin<TContract, TConfigSchema, TStateSchema> {
  readonly id: string;
  readonly type: PluginType;
  readonly contract: TContract;
  readonly configSchema: TConfigSchema;
  readonly stateSchema?: TStateSchema;
  
  initialize(config: ConfigType): Effect.Effect<void, ConfigurationError>;
  execute(input: any): Effect.Effect<any, PluginExecutionError>;
  shutdown(): Effect.Effect<void, never>;
}
```

## Core Properties

### Plugin Identity

Every plugin must define a unique identifier and type:

```typescript
export class MyPlugin implements Plugin<Contract, ConfigSchema, StateSchema> {
  readonly id = "my-plugin" as const;
  readonly type = "source" as const; // or "transformer", "pipeline"
  
  // Implementation...
}
```

The `id` serves as the registry key and must be unique across your plugin ecosystem. The `type` determines how the runtime handles the plugin and what interfaces it expects.

### Contract Definition

Plugins use [oRPC](https://orpc.io/) contracts to define their API surface:

```typescript
import { initORPC } from "@orpc/server";
import { z } from "zod";

const orpc = initORPC();

export const contract = orpc.contract({
  process: orpc.route({
    method: "POST",
    path: "/process",
    summary: "Process input data",
  })
    .input(z.object({
      data: z.string(),
      options: z.object({
        format: z.enum(["json", "xml"]).optional(),
      }).optional(),
    }))
    .output(z.object({
      result: z.string(),
      metadata: z.record(z.any()).optional(),
    })),
});

export class MyPlugin implements Plugin<typeof contract, ConfigSchema, StateSchema> {
  readonly contract = contract;
  // ...
}
```

### Configuration Schema

Define plugin configuration using [Zod](https://zod.dev/) schemas with the `createConfigSchema` helper:

```typescript
import { createConfigSchema } from "every-plugin";
import { z } from "zod";

export const MyPluginConfigSchema = createConfigSchema(
  // Variables schema (non-sensitive configuration)
  z.object({
    timeout: z.number().min(1000).max(300000).optional(),
    retryAttempts: z.number().min(0).max(10).optional(),
    baseUrl: z.string().url().optional(),
  }),
  // Secrets schema (sensitive configuration)
  z.object({
    apiKey: z.string().min(1, "API key is required"),
    clientSecret: z.string().min(1).optional(),
  })
);

export type MyPluginConfig = z.infer<typeof MyPluginConfigSchema>;
```

### State Schema (Optional)

For plugins that maintain state between executions:

```typescript
export const StateSchema = z.object({
  cursor: z.string().optional(),
  lastProcessedId: z.string().optional(),
  pageNumber: z.number().optional(),
  metadata: z.record(z.any()).optional(),
});

export type State = z.infer<typeof StateSchema>;
```

## Lifecycle Methods

### Initialize

The `initialize` method sets up the plugin with validated configuration:

```typescript
initialize(config: MyPluginConfig): Effect.Effect<void, ConfigurationError> {
  return Effect.gen(function* () {
    const logger = yield* PluginLoggerTag;
    
    // Validate configuration
    if (!config.secrets.apiKey) {
      return yield* Effect.fail(
        new ConfigurationError("API key is required")
      );
    }
    
    // Initialize resources
    this.client = new ApiClient({
      apiKey: config.secrets.apiKey,
      timeout: config.variables?.timeout || 30000,
      baseUrl: config.variables?.baseUrl || "https://api.example.com",
    });
    
    // Test connection
    yield* Effect.tryPromise({
      try: () => this.client.ping(),
      catch: (error) => new ConfigurationError(
        `Failed to connect to API: ${error}`
      ),
    });
    
    yield* logger.logInfo("Plugin initialized successfully");
  }).pipe(Effect.provide(this));
}
```

### Execute

The `execute` method handles plugin invocation with input validation:

```typescript
execute(input: any): Effect.Effect<any, PluginExecutionError> {
  return Effect.gen(function* () {
    if (!this.client) {
      return yield* Effect.fail(
        new PluginExecutionError("Plugin not initialized", false)
      );
    }
    
    // Route to appropriate procedure
    switch (input.procedure) {
      case "process":
        return yield* this.handleProcess(input.input);
      default:
        return yield* Effect.fail(
          new PluginExecutionError(`Unknown procedure: ${input.procedure}`, false)
        );
    }
  });
}

private handleProcess(input: ProcessInput): Effect.Effect<ProcessOutput, PluginExecutionError> {
  return Effect.gen(function* () {
    return yield* Effect.tryPromise({
      try: async () => {
        const result = await this.client.process(input.data, input.options);
        return {
          result: result.data,
          metadata: result.metadata,
        };
      },
      catch: (error) => new PluginExecutionError(
        `Processing failed: ${error}`,
        true // Retryable
      ),
    });
  });
}
```

### Shutdown

The `shutdown` method cleans up resources:

```typescript
shutdown(): Effect.Effect<void, never> {
  return Effect.gen(function* () {
    const logger = yield* PluginLoggerTag;
    
    if (this.client) {
      yield* Effect.promise(() => this.client.disconnect());
      this.client = null;
    }
    
    yield* logger.logInfo("Plugin shutdown complete");
  }).pipe(Effect.provide(this));
}
```

## Plugin Types

### Source Plugin

Source plugins fetch data from external systems:

```typescript
interface SourcePlugin<TContract, TConfigSchema, TStateSchema> 
  extends Plugin<TContract, TConfigSchema, TStateSchema> {
  readonly type: "source";
  isStreamable(procedureName: string): boolean;
}

export class MySourcePlugin implements SourcePlugin<Contract, ConfigSchema, StateSchema> {
  readonly type = "source" as const;
  
  isStreamable(procedureName: string): boolean {
    return procedureName === "search" || procedureName === "stream";
  }
  
  // Implementation...
}
```

### Transformer Plugin

Transformer plugins process and modify data:

```typescript
interface TransformerPlugin<TContract, TConfigSchema> 
  extends Plugin<TContract, TConfigSchema, never> {
  readonly type: "transformer";
}

export class MyTransformerPlugin implements TransformerPlugin<Contract, ConfigSchema> {
  readonly type = "transformer" as const;
  readonly stateSchema = undefined; // Transformers typically don't maintain state
  
  // Implementation...
}
```

### Pipeline Plugin

Pipeline plugins orchestrate multiple operations:

```typescript
interface PipelinePlugin<TContract, TConfigSchema, TStateSchema> 
  extends Plugin<TContract, TConfigSchema, TStateSchema> {
  readonly type: "pipeline";
}

export class MyPipelinePlugin implements PipelinePlugin<Contract, ConfigSchema, StateSchema> {
  readonly type = "pipeline" as const;
  
  // Implementation...
}
```

## Error Handling

Plugins should use typed errors for consistent error handling:

```typescript
import { ConfigurationError, PluginExecutionError } from "every-plugin";

// Configuration errors (non-retryable)
return yield* Effect.fail(
  new ConfigurationError("Invalid API endpoint URL")
);

// Execution errors (can be retryable)
return yield* Effect.fail(
  new PluginExecutionError("Rate limit exceeded", true) // Retryable
);

return yield* Effect.fail(
  new PluginExecutionError("Invalid input format", false) // Not retryable
);
```

## Resource Management

Plugins should properly manage resources:

```typescript
export class ResourceAwarePlugin implements Plugin<Contract, ConfigSchema> {
  private connections: Connection[] = [];
  private timers: NodeJS.Timeout[] = [];
  
  initialize(config: Config): Effect.Effect<void, ConfigurationError> {
    return Effect.gen(function* () {
      // Create managed resources
      const connection = yield* Effect.acquireRelease(
        Effect.promise(() => createConnection(config)),
        (conn) => Effect.promise(() => conn.close())
      );
      
      this.connections.push(connection);
    });
  }
  
  shutdown(): Effect.Effect<void, never> {
    return Effect.gen(function* () {
      // Clean up all resources
      yield* Effect.all(
        this.connections.map(conn => 
          Effect.promise(() => conn.close())
        )
      );
      
      this.timers.forEach(timer => clearTimeout(timer));
      this.connections = [];
      this.timers = [];
    });
  }
}
```

## Next Steps

<Cards>
  <Card title="Testing" href="/docs/core/testing">
    Learn testing strategies and patterns
  </Card>
  <Card title="Types" href="/docs/core/types">
    Explore the type system and schemas
  </Card>
  <Card title="Lifecycle" href="/docs/core/lifecycle">
    Understand plugin lifecycle stages
  </Card>
  <Card title="Plugin Creation" href="/docs/plugins/getting-started">
    Start building your first plugin
  </Card>
</Cards>
