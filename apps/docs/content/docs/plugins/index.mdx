---
title: Creating Plugins
description: Build type-safe plugins with oRPC contracts
---

Plugins are built using the `createPlugin()` factory with [oRPC](https://orpc.unnoq.com/) contracts. This guide provides copy-paste templates and patterns for common plugin types.

## Plugin Anatomy

Every plugin has four key parts:

1. **Contract** - oRPC routes defining procedures, inputs, and outputs
2. **Config Schema** - Variables (non-sensitive) and secrets (sensitive) configuration
3. **Initialize** - Setup lifecycle that returns context for handlers
4. **Router** - oRPC handlers that implement the contract

### Type Export

`createPlugin()` automatically exports the plugin type in its default export. Consumers can import this type for compile-time type safety:

```typescript
// In your plugin package
export default createPlugin({
  id: "my-plugin",
  // ... plugin definition
});

// Consumers install as dev dependency
// bun add -D @my-org/my-plugin

// Then import type-only for bindings
import type MyPlugin from "@my-org/my-plugin";
import type { PluginBinding } from "every-plugin";

type AppBindings = {
  "my-plugin": PluginBinding<typeof MyPlugin>;
};
```

This provides autocomplete, type inference, and compile-time validation in the consumer's runtime.

```typescript
import { createPlugin } from "every-plugin";
import { Effect } from "every-plugin/effect";
import { oc, implement } from "every-plugin/orpc";
import { z } from "every-plugin/zod";

export default createPlugin({
  id: "my-plugin",
  
  // Define oRPC contract
  contract: oc.router({
    getData: oc.route({ method: 'POST', path: '/getData' })
      .input(z.object({ id: z.string() }))
      .output(z.object({ data: z.string() }))
  }),
  
  // Configuration schemas
  variables: z.object({
    timeout: z.number().default(30000)
  }),
  secrets: z.object({
    apiKey: z.string()
  }),
  
  // Initialize with context
  initialize: (config) => Effect.gen(function* () {
    const client = new ApiClient(config.secrets.apiKey);
    return { client }; // Context passed to router
  }),
  
  // Create router with handlers
  createRouter: (context, builder) => {
    // builder is already: implement(contract).$context<TContext>()
    return {
      getData: builder.getData.handler(async ({ input }) => {
        const data = await context.client.fetchData(input.id);
        return { data };
      })
    };
  }
});
```

## Key Principles

### Import Through every-plugin

Always import Effect, oRPC, and Zod through `every-plugin`:

```typescript
import { Effect, Stream, Queue, Scope } from "every-plugin/effect";
import { oc, implement, eventIterator } from "every-plugin/orpc";
import { z } from "every-plugin/zod";
```

This ensures version consistency across your plugin ecosystem.

### Context Flow

Context flows from `initialize` → `createRouter` → handlers:

```typescript
// 1. Initialize returns context
initialize: (config) => Effect.gen(function* () {
  const client = new ApiClient(config.secrets.apiKey);
  const cache = new Map();
  return { client, cache }; // This is your context
}),

// 2. createRouter receives context
createRouter: (context, builder) => {
  // context.client and context.cache available
  // builder is already: implement(contract).$context<TContext>()

  return {
    // 3. Handlers access context
    getData: builder.getData.handler(async ({ input }) => {
      return await context.client.fetch(input.id);
    })
  };
}
```

### Resource Management

Use `Effect.acquireRelease` for long-lived resources in `initialize`:

```typescript
initialize: (config) => Effect.gen(function* () {
  // Resources are scoped to plugin lifetime
  const queue = yield* Effect.acquireRelease(
    Queue.bounded(1000),
    (q) => Queue.shutdown(q)
  );
  
  return { queue };
})
```

### Background Tasks

Use `Effect.forkScoped` to start background tasks that live for the plugin's lifetime:

```typescript
initialize: (config) => Effect.gen(function* () {
  const queue = yield* Effect.acquireRelease(
    Queue.bounded(1000),
    (q) => Queue.shutdown(q)
  );
  
  // Background task runs until plugin shutdown
  yield* Effect.forkScoped(
    Effect.gen(function* () {
      while (true) {
        const item = yield* fetchFromAPI();
        yield* Queue.offer(queue, item);
        yield* Effect.sleep("1 second");
      }
    })
  );
  
  return { queue };
})
```

The background task is automatically interrupted when the plugin shuts down.
