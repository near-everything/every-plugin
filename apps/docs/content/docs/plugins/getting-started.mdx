---
title: Getting Started
description: Fork templates and create your first plugin
---

## Template Selection

Start by forking the appropriate template repository based on your plugin type:

### Source Plugin Template
For data fetching plugins with oRPC contracts:

```bash
git clone https://github.com/your-org/source-plugin-template my-source-plugin
cd my-source-plugin
npm install
```

### Standard Plugin Template
For transformer and distributor plugins:

```bash
git clone https://github.com/your-org/plugin-template my-plugin
cd my-plugin
npm install
```

## Template Structure

Both templates provide this structure:

<Files>
  <Folder name="my-plugin" defaultOpen>
    <File name="package.json" />
    <File name="rspack.config.cjs" />
    <File name="tsconfig.json" />
    <Folder name="src" defaultOpen>
      <File name="index.ts" />
      <File name="client.ts" />
      <Folder name="schemas">
        <File name="index.ts" />
      </Folder>
    </Folder>
  </Folder>
</Files>

## Define Your Plugin

### 1. Update Package Metadata

```json title="package.json"
{
  "name": "@my-org/my-plugin",
  "version": "1.0.0",
  "description": "My custom plugin for data processing",
  "main": "dist/remoteEntry.js"
}
```

### 2. Define Schemas

Create your input, output, and configuration schemas:

```typescript title="src/schemas/index.ts"
import { z } from "zod";
import { createConfigSchema } from "every-plugin";

// Data schemas
export const ItemSchema = z.object({
  id: z.string(),
  title: z.string(),
  content: z.string(),
  createdAt: z.string(),
});

// Input/Output schemas
export const InputSchema = z.object({
  items: z.array(z.string()),
  options: z.object({
    format: z.enum(["json", "xml"]).optional(),
  }).optional(),
});

export const OutputSchema = z.object({
  success: z.boolean(),
  data: z.object({
    items: z.array(ItemSchema),
    processed: z.number(),
  }),
});

// Configuration schema
export const ConfigSchema = createConfigSchema(
  // Variables (non-sensitive)
  z.object({
    timeout: z.number().default(30000),
    batchSize: z.number().default(100),
  }),
  // Secrets (sensitive)
  z.object({
    apiKey: z.string().min(1),
  })
);

export type Input = z.infer<typeof InputSchema>;
export type Output = z.infer<typeof OutputSchema>;
export type Config = z.infer<typeof ConfigSchema>;
```

### 3. Implement Plugin Class

```typescript title="src/index.ts"
import { Effect, PluginLoggerTag } from "every-plugin";
import type { Plugin, ConfigurationError, PluginExecutionError } from "every-plugin";
import { InputSchema, OutputSchema, ConfigSchema, type Input, type Output, type Config } from "./schemas";
import { ApiClient } from "./client";

export class MyPlugin implements Plugin<typeof InputSchema, typeof OutputSchema, typeof ConfigSchema> {
  readonly id = "my-plugin" as const;
  readonly type = "transformer" as const;
  readonly inputSchema = InputSchema;
  readonly outputSchema = OutputSchema;
  readonly configSchema = ConfigSchema;

  private client: ApiClient | null = null;

  initialize(config: Config): Effect.Effect<void, ConfigurationError> {
    return Effect.gen(function* () {
      const logger = yield* PluginLoggerTag;
      
      this.client = new ApiClient({
        apiKey: config.secrets.apiKey,
        timeout: config.variables?.timeout || 30000,
      });
      
      // Test connection
      yield* Effect.tryPromise({
        try: () => this.client.ping(),
        catch: (error) => new ConfigurationError(`Connection failed: ${error}`)
      });
      
      yield* logger.logInfo("Plugin initialized successfully");
    }).pipe(Effect.provide(this));
  }

  execute(input: Input): Effect.Effect<Output, PluginExecutionError> {
    return Effect.gen(function* () {
      if (!this.client) {
        return yield* Effect.fail(
          new PluginExecutionError("Plugin not initialized", false)
        );
      }

      const logger = yield* PluginLoggerTag;
      yield* logger.logInfo("Processing items", { count: input.items.length });

      // Process items
      const processedItems = yield* Effect.forEach(input.items, (item) =>
        Effect.tryPromise({
          try: () => this.client!.process(item),
          catch: (error) => new PluginExecutionError(`Processing failed: ${error}`, true)
        })
      );

      return {
        success: true,
        data: {
          items: processedItems,
          processed: processedItems.length,
        },
      };
    }).pipe(Effect.provide(this));
  }

  shutdown(): Effect.Effect<void, never> {
    return Effect.gen(function* () {
      const logger = yield* PluginLoggerTag;
      
      if (this.client) {
        yield* Effect.promise(() => this.client!.disconnect());
        this.client = null;
      }
      
      yield* logger.logInfo("Plugin shutdown complete");
    }).pipe(Effect.provide(this));
  }
}

// Export plugin instance
export default new MyPlugin();
```

### 4. Create API Client

```typescript title="src/client.ts"
export class ApiClient {
  constructor(private config: { apiKey: string; timeout: number }) {}

  async ping(): Promise<void> {
    // Test API connection
    const response = await fetch("https://api.example.com/ping", {
      headers: { Authorization: `Bearer ${this.config.apiKey}` },
      signal: AbortSignal.timeout(this.config.timeout),
    });
    
    if (!response.ok) {
      throw new Error(`API ping failed: ${response.status}`);
    }
  }

  async process(item: string): Promise<any> {
    // Process individual item
    const response = await fetch("https://api.example.com/process", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${this.config.apiKey}`,
      },
      body: JSON.stringify({ item }),
      signal: AbortSignal.timeout(this.config.timeout),
    });

    if (!response.ok) {
      throw new Error(`Processing failed: ${response.status}`);
    }

    return response.json();
  }

  async disconnect(): Promise<void> {
    // Cleanup connections
  }
}
```

## Development Workflow

### 1. Local Development

```bash
# Start development server
npm run dev
# Plugin available at http://localhost:3001/remoteEntry.js
```

### 2. Test Your Plugin

```typescript title="test.ts"
import { createPluginRuntime, PluginRuntime } from "every-plugin/runtime";

const runtime = createPluginRuntime({
  registry: {
    "my-plugin": {
      remoteUrl: "http://localhost:3001/remoteEntry.js",
      type: "transformer",
      version: "1.0.0",
    },
  },
  secrets: {
    API_KEY: "test-key",
  },
});

const result = await runtime.runPromise(
  Effect.gen(function* () {
    const pluginRuntime = yield* PluginRuntime;
    
    const plugin = yield* pluginRuntime.usePlugin("my-plugin", {
      secrets: { apiKey: "{{API_KEY}}" },
      variables: { timeout: 5000 },
    });
    
    return yield* pluginRuntime.executePlugin(plugin, {
      items: ["test1", "test2"],
    });
  })
);

console.log(result);
await runtime.dispose();
```

### 3. Build for Production

```bash
npm run build
# Creates dist/remoteEntry.js for deployment
```

## Next Steps

<Cards>
  <Card title="Source Plugins" href="/docs/plugins/source-plugins">
    Create data fetching plugins with oRPC contracts
  </Card>
  <Card title="Deployment" href="/docs/plugins/deployment">
    Build and deploy plugins to production
  </Card>
  <Card title="Examples" href="/docs/examples">
    See plugins in real-world scenarios
  </Card>
</Cards>
