---
title: Plugin Patterns
description: Copy-paste templates for common plugin scenarios
---

This cookbook provides complete, runnable patterns for creating plugins. All examples use the actual every-plugin API.

## Type Exports for Consumers

When you create a plugin with `createPlugin()`, it automatically exports the plugin type in its default export. Consumers will:

1. Install your plugin as a dev dependency: `bun add -D @my-org/my-plugin`
2. Import it type-only for type bindings: `import type MyPlugin from "@my-org/my-plugin"`
3. Use `PluginBinding<typeof MyPlugin>` for compile-time type safety

This provides consumers with autocomplete, type inference, and validation without bundling your plugin code.

## Copy-Paste Template

Full plugin template with inline comments:

```typescript
import { createPlugin, CommonPluginErrors } from "every-plugin";
import { Effect, Queue, Stream } from "every-plugin/effect";
import { oc, implement, eventIterator } from "every-plugin/orpc";
import { z } from "every-plugin/zod";

// 1. Define data schemas
const ItemSchema = z.object({
  externalId: z.string(),
  content: z.string(),
  createdAt: z.string().datetime().optional(),
  raw: z.unknown() // Original API response
});

// 2. Define oRPC contract
const contract = oc.router({
  // Single item fetch
  getById: oc
    .route({ method: 'POST', path: '/getById' })
    .input(z.object({ id: z.string() }))
    .output(z.object({ item: ItemSchema }))
    .errors(CommonPluginErrors),
  
  // Streaming procedure
  streamItems: oc
    .route({ method: 'POST', path: '/streamItems' })
    .input(z.object({ 
      query: z.string(),
      limit: z.number().optional()
    }))
    .output(eventIterator(z.object({
      item: ItemSchema,
      state: z.object({
        cursor: z.string().optional(),
        nextPollMs: z.number().nullable()
      })
    })))
    .errors(CommonPluginErrors)
});

// 3. Create API client (in separate file typically)
class ApiClient {
  constructor(private apiKey: string, private baseUrl: string) {}
  
  async fetchById(id: string) {
    const response = await fetch(`${this.baseUrl}/items/${id}`, {
      headers: { Authorization: `Bearer ${this.apiKey}` }
    });
    return response.json();
  }
  
  async *streamItems(query: string) {
    // Implement streaming logic
    yield { item: { externalId: "1", content: "test", raw: {} } };
  }
}

// 4. Create plugin
export default createPlugin({
  id: "my-plugin",
  contract,
  
  // Configuration schemas
  variables: z.object({
    baseUrl: z.string().url(),
    timeout: z.number().default(30000)
  }),
  secrets: z.object({
    apiKey: z.string().min(1)
  }),
  
  // Initialize with context
  initialize: (config) => Effect.gen(function* () {
    // Create API client
    const client = new ApiClient(
      config.secrets.apiKey,
      config.variables.baseUrl
    );
    
    // Optional: Create long-lived resources
    const queue = yield* Effect.acquireRelease(
      Queue.bounded(1000),
      (q) => Queue.shutdown(q)
    );
    
    // Optional: Start background tasks
    yield* Effect.forkScoped(
      Effect.gen(function* () {
        // Background work here
      })
    );
    
    // Return context for handlers
    return { client, queue };
  }),
  
  // Create router with handlers
  createRouter: (context) => {
    const os = implement(contract).$context<typeof context>();
    
    return os.router({
      getById: os.getById.handler(async ({ input, errors }) => {
        try {
          const data = await context.client.fetchById(input.id);
          return { item: data };
        } catch (error) {
          throw errors.SERVICE_UNAVAILABLE({
            message: "Failed to fetch item",
            data: { retryAfter: 30 }
          });
        }
      }),
      
      streamItems: os.streamItems.handler(async function* ({ input }) {
        yield* context.client.streamItems(input.query);
      })
    });
  }
});
```

## Simple Data Fetch

Basic plugin without streaming or background tasks:

```typescript
import { createPlugin } from "every-plugin";
import { Effect } from "every-plugin/effect";
import { oc, implement } from "every-plugin/orpc";
import { z } from "every-plugin/zod";

const ItemSchema = z.object({
  id: z.string(),
  data: z.string()
});

const contract = oc.router({
  getById: oc
    .route({ method: 'POST', path: '/getById' })
    .input(z.object({ id: z.string() }))
    .output(z.object({ item: ItemSchema })),
  
  getBulk: oc
    .route({ method: 'POST', path: '/getBulk' })
    .input(z.object({ ids: z.array(z.string()).max(100) }))
    .output(z.object({ items: z.array(ItemSchema) }))
});

class SimpleClient {
  constructor(private apiKey: string) {}
  
  async fetchOne(id: string) {
    const response = await fetch(`https://api.example.com/items/${id}`, {
      headers: { Authorization: `Bearer ${this.apiKey}` }
    });
    return response.json();
  }
  
  async fetchMany(ids: string[]) {
    const response = await fetch('https://api.example.com/items/bulk', {
      method: 'POST',
      headers: { 
        'Authorization': `Bearer ${this.apiKey}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ ids })
    });
    return response.json();
  }
}

export default createPlugin({
  id: "simple-plugin",
  contract,
  variables: z.object({
    timeout: z.number().default(30000)
  }),
  secrets: z.object({
    apiKey: z.string()
  }),
  initialize: (config) => Effect.gen(function* () {
    const client = new SimpleClient(config.secrets.apiKey);
    
    // Test connection
    yield* Effect.tryPromise({
      try: () => fetch('https://api.example.com/health'),
      catch: () => new Error("Connection failed")
    });
    
    return { client };
  }),
  createRouter: (context) => {
    const os = implement(contract).$context<typeof context>();
    
    return os.router({
      getById: os.getById.handler(async ({ input }) => {
        const item = await context.client.fetchOne(input.id);
        return { item };
      }),
      
      getBulk: os.getBulk.handler(async ({ input }) => {
        const items = await context.client.fetchMany(input.ids);
        return { items };
      })
    });
  }
});
```

## Background Producer

Plugin with background task populating a queue for streaming:

```typescript
import { createPlugin } from "every-plugin";
import { Effect, Queue } from "every-plugin/effect";
import { oc, implement, eventIterator } from "every-plugin/orpc";
import { z } from "every-plugin/zod";

const EventSchema = z.object({
  id: z.string(),
  timestamp: z.number(),
  data: z.unknown()
});

const contract = oc.router({
  // Stream events from background producer
  listen: oc
    .route({ method: 'POST', path: '/listen' })
    .input(z.object({
      maxEvents: z.number().optional()
    }))
    .output(eventIterator(EventSchema)),
  
  // Manually enqueue an event
  enqueue: oc
    .route({ method: 'POST', path: '/enqueue' })
    .input(z.object({
      data: z.unknown()
    }))
    .output(z.object({ success: z.boolean() }))
});

export default createPlugin({
  id: "background-plugin",
  contract,
  variables: z.object({
    pollIntervalMs: z.number().default(1000),
    maxEvents: z.number().optional()
  }),
  secrets: z.object({
    apiKey: z.string()
  }),
  initialize: (config) => Effect.gen(function* () {
    // Create queue as scoped resource
    const eventQueue = yield* Effect.acquireRelease(
      Queue.bounded(1000),
      (q) => Queue.shutdown(q)
    );
    
    // Start background producer
    yield* Effect.forkScoped(
      Effect.gen(function* () {
        let count = 0;
        const maxEvents = config.variables.maxEvents;
        
        while (!maxEvents || count < maxEvents) {
          // Fetch from external source
          const event = yield* Effect.tryPromise(() =>
            fetch('https://api.example.com/events/latest', {
              headers: { Authorization: `Bearer ${config.secrets.apiKey}` }
            }).then(r => r.json())
          ).pipe(
            Effect.catchAll(() => Effect.succeed(null))
          );
          
          if (event) {
            yield* Queue.offer(eventQueue, {
              id: event.id,
              timestamp: Date.now(),
              data: event
            }).pipe(
              Effect.catchAll(() => Effect.void)
            );
            count++;
          }
          
          // Wait before next poll
          yield* Effect.sleep(`${config.variables.pollIntervalMs} millis`);
        }
      })
    );
    
    return { eventQueue };
  }),
  createRouter: (context) => {
    const os = implement(contract).$context<typeof context>();
    
    return os.router({
      listen: os.listen.handler(async function* ({ input }) {
        let count = 0;
        const maxEvents = input.maxEvents;
        
        while (!maxEvents || count < maxEvents) {
          try {
            // Take from queue (blocks until available)
            const event = await Effect.runPromise(
              Queue.take(context.eventQueue)
            );
            yield event;
            count++;
          } catch {
            // Queue shutdown or error
            break;
          }
        }
      }),
      
      enqueue: os.enqueue.handler(async ({ input }) => {
        const event = {
          id: `manual-${Date.now()}`,
          timestamp: Date.now(),
          data: input.data
        };
        
        await Effect.runPromise(
          Queue.offer(context.eventQueue, event).pipe(
            Effect.catchAll(() => Effect.succeed(false))
          )
        );
        
        return { success: true };
      })
    });
  }
});
```

## Error Handling

Using `CommonPluginErrors` for consistent error responses:

```typescript
import { createPlugin, CommonPluginErrors } from "every-plugin";
import { Effect } from "every-plugin/effect";
import { oc, implement } from "every-plugin/orpc";
import { z } from "every-plugin/zod";

const contract = oc.router({
  getData: oc
    .route({ method: 'POST', path: '/getData' })
    .input(z.object({ id: z.string() }))
    .output(z.object({ data: z.string() }))
    .errors(CommonPluginErrors) // Include standard errors
});

export default createPlugin({
  id: "error-handling-plugin",
  contract,
  variables: z.object({}),
  secrets: z.object({
    apiKey: z.string()
  }),
  initialize: (config) => Effect.gen(function* () {
    const client = { apiKey: config.secrets.apiKey };
    return { client };
  }),
  createRouter: (context) => {
    const os = implement(contract).$context<typeof context>();
    
    return os.router({
      getData: os.getData.handler(async ({ input, errors }) => {
        try {
          const response = await fetch(`https://api.example.com/data/${input.id}`, {
            headers: { Authorization: `Bearer ${context.client.apiKey}` }
          });
          
          // Handle various error cases
          if (response.status === 401) {
            throw errors.UNAUTHORIZED({
              message: "Invalid API key",
              data: { 
                apiKeyProvided: true,
                authType: 'apiKey' as const
              }
            });
          }
          
          if (response.status === 403) {
            throw errors.FORBIDDEN({
              message: "Access denied to resource",
              data: {
                requiredPermissions: ['read:data'],
                action: 'fetch'
              }
            });
          }
          
          if (response.status === 429) {
            const retryAfter = parseInt(response.headers.get('Retry-After') || '60');
            throw errors.RATE_LIMITED({
              message: "Rate limit exceeded",
              data: {
                retryAfter,
                remainingRequests: 0,
                limitType: 'requests' as const
              }
            });
          }
          
          if (response.status === 503) {
            throw errors.SERVICE_UNAVAILABLE({
              message: "Service temporarily unavailable",
              data: {
                retryAfter: 30,
                maintenanceWindow: false
              }
            });
          }
          
          if (!response.ok) {
            throw errors.BAD_REQUEST({
              message: `Request failed: ${response.statusText}`,
              data: {}
            });
          }
          
          const data = await response.json();
          return { data: data.value };
          
        } catch (error) {
          // Re-throw oRPC errors
          if (error && typeof error === 'object' && 'code' in error) {
            throw error;
          }
          
          // Wrap unexpected errors
          throw errors.SERVICE_UNAVAILABLE({
            message: error instanceof Error ? error.message : 'Unknown error',
            data: { retryAfter: 10 }
          });
        }
      })
    });
  }
});
```

## Anti-Patterns to Avoid

### ❌ Not Using Scoped Resources

```typescript
// DON'T DO THIS
initialize: (config) => Effect.gen(function* () {
  const queue = Queue.bounded(1000); // Not scoped!
  return { queue };
})
```

```typescript
// DO THIS
initialize: (config) => Effect.gen(function* () {
  const queue = yield* Effect.acquireRelease(
    Queue.bounded(1000),
    (q) => Queue.shutdown(q) // Cleanup on shutdown
  );
  return { queue };
})
```

### ❌ Forgetting forkScoped for Background Tasks

```typescript
// DON'T DO THIS
initialize: (config) => Effect.gen(function* () {
  Effect.fork(backgroundTask); // Will be orphaned!
  return { };
})
```

```typescript
// DO THIS
initialize: (config) => Effect.gen(function* () {
  yield* Effect.forkScoped(backgroundTask); // Cleaned up on shutdown
  return { };
})
```

### ❌ Blocking in Async Generators

```typescript
// DON'T DO THIS
streamData: handler(async function* () {
  while (true) {
    const data = await heavyComputation(); // Blocks!
    yield data;
  }
})
```

```typescript
// DO THIS
streamData: handler(async function* () {
  while (true) {
    const data = await heavyComputation();
    yield data;
    await new Promise(resolve => setTimeout(resolve, 10)); // Allow yielding
  }
})
```

## Deployment Checklist

Before deploying your plugin:

- [ ] Contract procedures have input/output schemas
- [ ] Error paths tested with `CommonPluginErrors`
- [ ] Resources use `Effect.acquireRelease`
- [ ] Background tasks use `Effect.forkScoped`
- [ ] Queue shutdown handled in cleanup
- [ ] Streaming procedures properly yield control
- [ ] Secrets properly hydrated via `{{TEMPLATE}}`
- [ ] API client connection tested in `initialize`
- [ ] All imports from `every-plugin/*`
- [ ] Build produces valid `remoteEntry.js`