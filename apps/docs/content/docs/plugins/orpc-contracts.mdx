---
title: oRPC Contracts
description: Define type-safe plugin APIs with oRPC
---

## Contract Basics

Plugins use [oRPC](https://orpc.io/) for type-safe API contracts. See the official oRPC documentation for complete details:

- [Define Contract](https://orpc.unnoq.com/docs/contract-first/define-contract)
- [Implement Contract](https://orpc.unnoq.com/docs/contract-first/implement-contract)

## Simple Contract

Define procedures with input/output schemas:

```typescript
import { oc } from "@orpc/contract";
import { z } from "zod";

const contract = {
  process: oc
    .input(z.object({
      items: z.array(z.string()),
      options: z.object({
        format: z.enum(["json", "xml"]).optional()
      }).optional()
    }))
    .output(z.object({
      processed: z.array(z.string()),
      count: z.number()
    }))
};
```

## Source Plugin Contract

Source plugins typically expose multiple procedures:

```typescript
const sourceContract = {
  // Single item fetch
  getById: oc
    .input(z.object({ id: z.string() }))
    .output(z.object({ item: ItemSchema.optional() })),

  // Bulk fetch
  getBulk: oc
    .input(z.object({ ids: z.array(z.string()).max(100) }))
    .output(z.object({ items: z.array(ItemSchema) })),

  // Streamable search
  search: oc
    .input(z.object({
      query: z.string().min(1),
      limit: z.number().min(1).max(1000).optional()
    }))
    .output(z.object({
      items: z.array(ItemSchema),
      nextState: StateSchema // Required for streaming
    }))
};
```

## Data Schemas

Define your data structures:

```typescript
const ItemSchema = z.object({
  externalId: z.string(),
  content: z.string(),
  contentType: z.string().optional(),
  createdAt: z.string().datetime().optional(),
  url: z.string().url().optional(),
  authors: z.array(z.object({
    id: z.string().optional(),
    username: z.string().optional(),
    displayName: z.string().optional()
  })).optional(),
  raw: z.unknown() // Original API response
});
```

## Contract Implementation

Implement contracts using oRPC patterns:

```typescript
import { implement } from "@orpc/server";

export class MyPlugin extends SimplePlugin<typeof contract, ConfigSchema> {
  createRouter() {
    const os = implement(this.contract);

    return os.router({
      process: os.process.handler(async ({ input }) => {
        const processed = input.items.map(item => 
          input.options?.format === "xml" 
            ? `<item>${item}</item>`
            : `{"item":"${item}"}`
        );
        
        return {
          processed,
          count: processed.length
        };
      })
    });
  }
}
```

## Streaming Contracts

For streaming, include `nextState` in output:

```typescript
const streamingContract = {
  search: oc
    .input(z.object({
      query: z.string(),
      limit: z.number().optional()
    }))
    .output(z.object({
      items: z.array(ItemSchema),
      nextState: StateSchema // Enables streaming
    }))
};

// Implementation with state handling
search: os.search.handler(async ({ input, context }) => {
  const state = context?.state;
  const results = await this.searchAPI(input.query, {
    cursor: state?.cursor,
    limit: input.limit
  });

  return {
    items: results.items,
    nextState: results.hasMore ? {
      cursor: results.nextCursor,
      nextPollMs: 1000 // Control timing
    } : null
  };
})
```

## Context and Middleware

Use oRPC middleware for state injection:

```typescript
export class MySourcePlugin extends SimplePlugin<Contract, ConfigSchema, StateSchema> {
  createRouter() {
    const os = implement(this.contract);
    
    // State middleware for streaming procedures
    const stateMiddleware = os
      .$context<{ state?: z.infer<typeof StateSchema> }>()
      .middleware(async ({ context, next }) => {
        return next({ context: { state: context.state } });
      });

    return os.router({
      getById: os.getById.handler(async ({ input }) => {
        // No state needed
        const item = await this.fetchById(input.id);
        return { item };
      }),

      search: os.use(stateMiddleware).search.handler(async ({ input, context }) => {
        // State available via context
        const state = context.state;
        const results = await this.search(input.query, state);
        
        return {
          items: results.items,
          nextState: results.nextState
        };
      })
    });
  }
}
```

## Error Handling

Handle errors in contract implementations:

```typescript
process: os.process.handler(async ({ input }) => {
  try {
    const result = await this.processItems(input.items);
    return { processed: result, count: result.length };
  } catch (error) {
    // oRPC will handle error serialization
    throw new Error(`Processing failed: ${error}`);
  }
})
```

## Contract Validation

oRPC automatically validates input/output against schemas:

```typescript
// Input validation happens automatically
search: os.search.handler(async ({ input }) => {
  // input is validated against contract input schema
  // TypeScript knows input.query is string, input.limit is number | undefined
  
  const results = await this.searchAPI(input.query, input.limit);
  
  // Output validation happens automatically
  return {
    items: results.items, // Must match ItemSchema[]
    nextState: results.nextState // Must match StateSchema
  };
})
```

## Contract Testing

Test contracts independently:

```typescript
import { call } from "@orpc/server";

describe("Plugin Contract", () => {
  it("should process items correctly", async () => {
    const plugin = new MyPlugin();
    await plugin.initialize(testConfig);
    
    const router = plugin.createRouter();
    
    const result = await call(router.process, {
      items: ["test1", "test2"],
      options: { format: "json" }
    });
    
    expect(result.processed).toHaveLength(2);
    expect(result.count).toBe(2);
  });
});
```

oRPC provides the foundation for type-safe, validated plugin APIs. See the [oRPC documentation](https://orpc.unnoq.com/) for advanced patterns.
