---
title: Testing & Deployment
description: Test plugins and deploy with Module Federation
---

## Plugin Testing

Use the testing helpers for unit tests:

```typescript
import { createTestPluginRuntime } from "every-plugin/testing";
import { Effect } from "effect";

describe("MyPlugin", () => {
  let testRuntime: ReturnType<typeof createTestPluginRuntime>;

  beforeEach(() => {
    testRuntime = createTestPluginRuntime(
      {
        registry: {
          "my-plugin": {
            remoteUrl: "mock://my-plugin",
            type: "transformer",
            version: "1.0.0"
          }
        },
        secrets: { API_KEY: "test-key" }
      },
      {
        "my-plugin": MyPlugin // Your plugin class
      }
    );
  });

  afterEach(async () => {
    await testRuntime.dispose();
  });

  it("should process items correctly", async () => {
    const result = await testRuntime.runPromise(
      Effect.gen(function* () {
        const pluginRuntime = yield* PluginRuntime;
        
        const plugin = yield* pluginRuntime.usePlugin("my-plugin", {
          secrets: { apiKey: "{{API_KEY}}" },
          variables: { timeout: 5000 }
        });
        
        return yield* pluginRuntime.executePlugin(plugin, {
          items: ["test1", "test2"]
        });
      })
    );

    expect(result.processed).toHaveLength(2);
    expect(result.processed[0]).toBe("processed-test1");
  });
});
```

## Contract Testing

Test oRPC contracts directly:

```typescript
import { call } from "@orpc/server";

describe("Plugin Contract", () => {
  let plugin: MyPlugin;

  beforeEach(async () => {
    plugin = new MyPlugin();
    await Effect.runPromise(plugin.initialize({
      secrets: { apiKey: "test-key" },
      variables: { timeout: 5000 }
    }));
  });

  afterEach(async () => {
    await Effect.runPromise(plugin.shutdown());
  });

  it("should handle process procedure", async () => {
    const router = plugin.createRouter();
    
    const result = await call(router.process, {
      items: ["item1", "item2"],
      options: { format: "json" }
    });
    
    expect(result.processed).toHaveLength(2);
    expect(result.count).toBe(2);
  });
});
```

## Streaming Tests

Test streaming behavior:

```typescript
describe("Streaming Plugin", () => {
  it("should stream items with state", async () => {
    const results = await testRuntime.runPromise(
      Effect.gen(function* () {
        const pluginRuntime = yield* PluginRuntime;
        
        const stream = yield* pluginRuntime.streamPlugin(
          "my-source-plugin",
          config,
          {
            procedure: "search",
            input: { query: "test" },
            state: null
          },
          { maxInvocations: 3 }
        );
        
        return yield* stream.pipe(Stream.runCollect);
      })
    );
    
    expect(results.length).toBeGreaterThan(0);
  });
});
```

## Build Configuration

Configure Module Federation for deployment:

```javascript
// rspack.config.cjs
const { ModuleFederationPlugin } = require("@module-federation/enhanced/rspack");

module.exports = {
  mode: process.env.NODE_ENV || "production",
  entry: "./src/index.ts",
  plugins: [
    new ModuleFederationPlugin({
      name: "my-plugin",
      filename: "remoteEntry.js",
      exposes: {
        "./plugin": "./src/index.ts"
      },
      shared: {
        "every-plugin": { singleton: true },
        "effect": { singleton: true },
        "zod": { singleton: true },
        "@orpc/server": { singleton: true }
      }
    })
  ],
  resolve: {
    extensions: [".ts", ".js"]
  },
  module: {
    rules: [
      {
        test: /\.ts$/,
        use: "ts-loader",
        exclude: /node_modules/
      }
    ]
  }
};
```

## Build Commands

```json
{
  "scripts": {
    "dev": "rspack serve --mode development",
    "build": "rspack build --mode production",
    "test": "vitest"
  }
}
```

## Deployment

Build and deploy your plugin:

```bash
# Build for production
npm run build

# Deploy dist/remoteEntry.js to your CDN
aws s3 cp dist/ s3://my-plugins-bucket/my-plugin@1.0.0/ --recursive

# Update plugin registry
{
  "my-plugin": {
    "remoteUrl": "https://cdn.example.com/plugins/my-plugin@1.0.0/remoteEntry.js",
    "type": "transformer",
    "version": "1.0.0"
  }
}
```

## Integration Testing

Test deployed plugins:

```typescript
const integrationTest = async () => {
  const runtime = createPluginRuntime({
    registry: {
      "my-plugin": {
        remoteUrl: "https://cdn.example.com/plugins/my-plugin@1.0.0/remoteEntry.js",
        type: "transformer",
        version: "1.0.0"
      }
    },
    secrets: { API_KEY: process.env.TEST_API_KEY }
  });

  try {
    const result = await runtime.runPromise(
      Effect.gen(function* () {
        const pluginRuntime = yield* PluginRuntime;
        
        const plugin = yield* pluginRuntime.usePlugin("my-plugin", {
          secrets: { apiKey: "{{API_KEY}}" }
        });
        
        return yield* pluginRuntime.executePlugin(plugin, {
          items: ["integration-test"]
        });
      })
    );

    console.log("Integration test passed:", result);
  } catch (error) {
    console.error("Integration test failed:", error);
    process.exit(1);
  } finally {
    await runtime.dispose();
  }
};
```

## CI/CD Pipeline

Example GitHub Actions workflow:

```yaml
name: Build and Deploy Plugin

on:
  push:
    tags: ['v*']

jobs:
  test-and-deploy:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Run tests
        run: npm test
        
      - name: Build plugin
        run: npm run build
        
      - name: Deploy to CDN
        run: |
          aws s3 sync dist/ s3://my-plugins-bucket/my-plugin@${{ github.ref_name }}/
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          
      - name: Integration test
        run: npm run test:integration
        env:
          TEST_API_KEY: ${{ secrets.TEST_API_KEY }}
```

## Plugin Versioning

Use semantic versioning for plugins:

```json
{
  "name": "@my-org/my-plugin",
  "version": "1.2.3"
}
```

Deploy with version-specific URLs:
- `my-plugin@1.2.3` - Specific version
- `my-plugin@latest` - Latest stable version

That covers testing and deployment. The testing helpers make unit testing straightforward, and Module Federation handles the deployment complexity.
