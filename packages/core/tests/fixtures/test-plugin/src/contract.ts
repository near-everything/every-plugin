import { CommonPluginErrors } from "every-plugin";
import { eventIterator, oc } from "every-plugin/orpc";
import { z } from "every-plugin/zod";

// Define schemas for your data types
export const testItemSchema = z.object({
	externalId: z.string().describe("Unique identifier for the test item"),
	content: z.string().describe("Content of the test item"),
	raw: z.unknown().describe("Original API response data"),
});

// Schema for streaming events
export const streamEventSchema = z.object({
	item: testItemSchema,
	state: z.object({
		nextPollMs: z.number().nullable().describe("Milliseconds until next poll, null if complete"),
		lastId: z.string().describe("Last processed item ID for resume"),
	}),
	metadata: z.object({
		itemIndex: z.number().describe("Sequential index of this item in the stream"),
	})
});

// Schema for background producer events
export const backgroundEventSchema = z.object({
	id: z.string().describe("Event identifier"),
	index: z.number().describe("Sequential event index"),
	timestamp: z.number().describe("Unix timestamp in milliseconds"),
});

export const testContract = oc.router({
	// Basic single item fetch
	getById: oc
		.route({
			method: 'GET',
			path: '/items/{id}',
			summary: 'Get item by ID',
			description: 'Fetches a single test item by its unique identifier. This is the primary method for retrieving individual items.',
			tags: ['Items'],
		})
		.input(z.object({
			id: z.string().describe('Unique item identifier')
		}))
		.output(z.object({
			item: testItemSchema
		}))
		.errors(CommonPluginErrors),

	// Basic bulk fetch
	getBulk: oc
		.route({
			method: 'GET',
			path: '/items',
			summary: 'Get multiple items',
			description: 'Fetches multiple test items. Use query parameters to filter results.',
			tags: ['Items'],
		})
		.input(z.object({
			ids: z.array(z.string()).describe('Array of item IDs to fetch'),
		}))
		.output(z.object({
			items: z.array(testItemSchema),
		}))
		.errors(CommonPluginErrors),

	// Simple streaming
	simpleStream: oc
		.route({
			method: 'GET',
			path: '/items/stream',
			summary: 'Stream items',
			description: 'Returns a fixed number of test items as a server-side event stream. Useful for testing streaming functionality.',
			tags: ['Streaming'],
		})
		.input(z.object({
			count: z.number().min(1).max(10).default(3).describe('Number of items to stream (1-10)'),
			prefix: z.string().default("item").describe('Prefix for generated item titles'),
		}))
		.output(eventIterator(streamEventSchema))
		.errors(CommonPluginErrors),

	// Empty stream
	emptyStream: oc
		.route({
			method: 'GET',
			path: '/items/stream/empty',
			summary: 'Empty stream',
			description: 'Returns an empty stream for testing edge cases. Useful for testing how clients handle empty iterators.',
			tags: ['Streaming'],
		})
		.input(z.object({
			reason: z.string().optional().describe('Optional reason for empty stream'),
		}))
		.output(eventIterator(streamEventSchema))
		.errors(CommonPluginErrors),

	// Consolidated error testing procedure
	throwError: oc
		.route({
			method: 'POST',
			path: '/errors/test',
			summary: 'Throw test error',
			description: 'Deliberately throws different types of errors for testing error handling. Useful for validating client error handling.',
			tags: ['Testing'],
		})
		.input(z.object({
			errorType: z.enum(['UNAUTHORIZED', 'FORBIDDEN', 'RATE_LIMITED', 'SERVICE_UNAVAILABLE']).describe('Type of error to throw'),
			customMessage: z.string().optional().describe('Optional custom error message'),
		}))
		.output(z.object({ message: z.string() }))
		.errors(CommonPluginErrors),

	// Config validation testing
	requiresSpecialConfig: oc
		.route({
			method: 'GET',
			path: '/config/test',
			summary: 'Test configuration',
			description: 'Validates that the plugin configuration is working correctly. Returns configuration values for verification.',
			tags: ['Testing'],
		})
		.input(z.object({
			checkValue: z.string().describe('Value to verify in response'),
		}))
		.output(z.object({
			configValue: z.string(),
			inputValue: z.string(),
		}))
		.errors(CommonPluginErrors),

	// Background producer streaming
	listenBackground: oc
		.route({
			method: 'GET',
			path: '/background/events',
			summary: 'Listen to background events',
			description: 'Streams background events generated by the plugin. Supports resume from last event ID for serverless environments.',
			tags: ['Streaming', 'Background'],
		})
		.input(z.object({
			maxResults: z.number().min(1).max(100).optional().describe('Maximum number of events to return'),
			lastEventId: z.string().optional().describe('Resume from this event ID (for serverless resume)'),
		}))
		.output(eventIterator(backgroundEventSchema))
		.errors(CommonPluginErrors),

	// Utility to manually enqueue background events
	enqueueBackground: oc
		.route({
			method: 'POST',
			path: '/background/events',
			summary: 'Enqueue background event',
			description: 'Manually adds an event to the background stream. Useful for testing event broadcasting.',
			tags: ['Background', 'Testing'],
		})
		.input(z.object({
			id: z.string().optional().describe('Optional custom event ID'),
		}))
		.output(z.object({
			ok: z.boolean(),
		}))
		.errors(CommonPluginErrors),

	// Simple ping for testing client dispatch
	ping: oc
		.route({
			method: 'GET',
			path: '/ping',
			summary: 'Health check',
			description: 'Simple ping endpoint to verify the plugin is responding correctly.',
			tags: ['Health'],
		})
		.output(z.object({
			ok: z.boolean(),
			timestamp: z.number(),
		}))
		.errors(CommonPluginErrors),

	// Variable serialization testing
	useClient: oc
		.route({
			method: 'POST',
			path: '/client/test',
			summary: 'Test client variable',
			description: 'Tests that client objects with methods are preserved through Module Federation.',
			tags: ['Testing'],
		})
		.input(z.object({
			id: z.string().describe('ID to pass to client method'),
		}))
		.output(z.object({
			result: z.string(),
			clientType: z.string(),
			hasGetDataMethod: z.boolean(),
			hasGetBaseUrlMethod: z.boolean(),
		}))
		.errors(CommonPluginErrors),
});
