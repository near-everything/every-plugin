import { z } from 'zod';
import type { Config, Input, Output, Plugin } from './plugin.js';
import { ErrorDetailsSchema } from './plugin.js';

/**
 * Zod schema for the Author interface
 */
export const authorSchema = z.object({
  id: z.string().optional(),
  username: z.string().optional(),
  displayName: z.string().optional(),
  url: z.string().optional(),
});

/**
 * Zod schema for PluginSourceItem - defines the structure that plugins must return
 */
export const pluginSourceItemSchema = z.object({
  externalId: z.string(),
  content: z.string(),
  contentType: z.string().optional(),
  createdAt: z.string().optional(),
  url: z.string().optional(),
  authors: z.array(authorSchema).optional(),
  raw: z.unknown(),
});

/**
 * Standard content types supported by the system.
 * Plugins can extend this with custom types.
 */
export const ContentType = {
  POST: 'post',
  ARTICLE: 'article',
  VIDEO: 'video',
  PODCAST: 'podcast',
  WEBSITE: 'website',
  FEED: 'feed',
  DATABASE_ENTRY: 'database-entry',
  UNKNOWN: 'unknown',
} as const;

export type ContentType = typeof ContentType[keyof typeof ContentType];

/**
 * Represents a single author - derived from the authorSchema
 */
export type Author = z.infer<typeof authorSchema>;

/**
 * Base PluginSourceItem type derived from schema (with unknown raw type)
 */
export type BasePluginSourceItem = z.infer<typeof pluginSourceItemSchema>;

/**
 * This is the data structure a plugin is responsible for creating.
 * It's generic over the raw data type.
 */
export interface PluginSourceItem<TRaw = Record<string, any>> extends Omit<BasePluginSourceItem, 'raw'> {
  // The raw, untouched data from the source API
  raw: TRaw;
}

/**
 * This is the final, canonical data structure used within the system.
 * It extends PluginSourceItem with system-generated fields.
 */
export interface SourceItem<TRaw = Record<string, any>> extends PluginSourceItem<TRaw> {
  id: string; // Unique internal ID, generated by the worker
  createdAt: string; // Guaranteed to exist (worker provides a default)

  // System-injected metadata for traceability
  metadata: {
    sourcePlugin: string;
    workflowId: string;
    runId: string;
    [key: string]: any;
  };
}

/**
 * Defines the progress of a job submitted to an external asynchronous service (e.g., Masa).
 */
export interface AsyncJobProgress {
  workflowId: string;
  status: "submitted" | "pending" | "processing" | "done" | "error" | "timeout";
  submittedAt: string; // ISO timestamp
  lastCheckedAt?: string; // ISO timestamp
  errorMessage?: string;
  // Optionally, store the original query or parameters for this job
  // queryDetails?: Record<string, any>;
}

export const AsyncJobProgressSchema = z.object({
  workflowId: z.string(),
  status: z.enum(["submitted", "pending", "processing", "done", "error", "timeout"]),
  submittedAt: z.string(), // ISO timestamp
  lastCheckedAt: z.string().optional(), // ISO timestamp
  errorMessage: z.string().optional(),
});


/**
 * Generic platform-specific state for managing resumable searches and long-running jobs.
 */
export interface PlatformState {
  // For overall resumable search (across multiple jobs/chunks)
  // This cursor can be a string, number, or a more complex object
  // depending on the platform's pagination/cursor mechanism.
  latestProcessedId?: string | number | Record<string, any>;

  // For the currently active job (e.g., a Masa search job for one chunk)
  currentAsyncJob?: AsyncJobProgress | null;

  // Allows for other platform-specific state variables
  [key: string]: any;
}

export const PlatformStateSchema = z.object({
  latestProcessedId: z.union([z.string(), z.number(), z.record(z.string(), z.any())]).optional(),
  currentAsyncJob: AsyncJobProgressSchema.nullable().optional(),
}).catchall(z.any());

/**
 * State passed between search calls to enable resumption.
 * TData is expected to be an object conforming to PlatformState or a derivative.
 */
export interface LastProcessedState<
  TData extends PlatformState = PlatformState,
> {
  // The `data` field holds the strongly-typed, platform-specific state.
  data: TData;
  // Optional: A unique identifier for this state object itself, if needed for storage/retrieval.
  // id?: string;
  // Optional: Timestamp of when this state was generated.
  // timestamp?: number;
}

// Source-specific plugin types that extend the base plugin types
export type SourceConfig<
  V extends z.ZodTypeAny = z.ZodRecord<z.ZodString, z.ZodUnknown>,
  S extends z.ZodTypeAny = z.ZodRecord<z.ZodString, z.ZodUnknown>
> = Config<V, S>;

export interface SourceInput<TSearchOptions extends z.ZodTypeAny = z.ZodTypeAny> extends Input<z.ZodAny> {
  searchOptions: TSearchOptions;
  lastProcessedState?: LastProcessedState<PlatformState> | null;
}

export interface PluginSourceInput<TSearchOptions = Record<string, unknown>> extends Input<z.ZodAny> {
  searchOptions: TSearchOptions;
  lastProcessedState?: LastProcessedState<PlatformState> | null;
}

export interface PluginSourceOutputData<TItem extends PluginSourceItem = PluginSourceItem> {
  items: TItem[];
  nextLastProcessedState?: PlatformState | null;
}

// The output from a source plugin's execute method
export interface PluginSourceOutput<TItem extends PluginSourceItem = PluginSourceItem> extends Output<z.ZodAny> {
  success: boolean;
  data?: PluginSourceOutputData<TItem>;
  errors?: Array<{ message: string; details?: Record<string, unknown>; stack?: string }>;
}

// The final output data after system enrichment (used internally by workers)
export interface SourceOutputData {
  items: SourceItem[];
  nextLastProcessedState?: PlatformState | null;
}

// The final output after system enrichment (used internally by workers)
export interface SourceOutput extends Output<z.ZodAny> {
  success: boolean;
  data?: SourceOutputData;
  errors?: Array<{ message: string; details?: Record<string, unknown>; stack?: string }>;
}

// Source plugin interface that extends the base Plugin interface
export interface SourcePlugin<
  TInputSchema extends z.ZodTypeAny = z.ZodTypeAny,
  TOutputSchema extends z.ZodTypeAny = z.ZodTypeAny,
  TConfigSchema extends z.ZodTypeAny = z.ZodTypeAny
> extends Plugin<TInputSchema, TOutputSchema, TConfigSchema> {
  readonly type: 'source';
}

// Source-specific schema creators
export const createSourceInputSchema = <
  TSearchOptions extends z.ZodTypeAny,
  TState extends z.ZodTypeAny
>(
  searchOptionsSchema: TSearchOptions,
  stateSchema: TState,
) =>
  z.object({
    searchOptions: searchOptionsSchema,
    lastProcessedState: z.object({
      data: stateSchema.optional().nullable()
    }).optional().nullable(),
  });

export const createSourceOutputSchema = <
  TItem extends z.ZodTypeAny,
  TState extends z.ZodTypeAny
>(
  itemData: TItem,
  stateSchema: TState,
) => {
  const pluginSourceItemSchema = z.object({
    externalId: z.string(),
    content: z.string(),
    contentType: z.string().optional(),
    createdAt: z.string().optional(),
    url: z.string().optional(),
    authors: z.array(authorSchema).optional(),
    raw: itemData,
  });

  return z.object({
    success: z.boolean(),
    data: z.object({
      items: z.array(pluginSourceItemSchema),
      nextLastProcessedState: stateSchema.optional().nullable(),
    }).optional(),
    errors: z.array(ErrorDetailsSchema).optional(),
  });
};
