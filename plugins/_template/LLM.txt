# every-plugin Template Guide

This guide explains how to build plugins for the every-plugin framework. The template demonstrates a simple, clean pattern using plain TypeScript classes. Advanced patterns (background processing, queues, etc.) are covered at the end.

## Architecture Overview

Every plugin consists of three core files:

1. **contract.ts** - Defines the plugin's public API using oRPC
2. **service.ts** - Plain class that wraps your external API  
3. **index.ts** - Wires everything together with createPlugin

```
plugins/your-plugin/
├── src/
│   ├── contract.ts    # API contract (procedures, schemas)
│   ├── service.ts     # Service class with Effect error handling
│   ├── index.ts       # Plugin implementation (createPlugin)
│   └── __tests__/     # Integration & unit tests
├── package.json
├── tsconfig.json
└── README.md
```

## Step-by-Step: Building a Plugin

### Step 1: Define Your Contract (contract.ts)

The contract defines what procedures your plugin exposes.

```typescript
import { CommonPluginErrors } from "every-plugin";
import { eventIterator, oc } from "every-plugin/orpc";
import { z } from "every-plugin/zod";

// Define schemas for your data types
export const ItemSchema = z.object({
  id: z.string(),
  title: z.string(),
  createdAt: z.string().datetime(),
});

// Create the contract
export const contract = oc.router({
  // Single item fetch
  getById: oc
    .route({ method: 'GET', path: '/items/{id}' })
    .input(z.object({ id: z.string() }))
    .output(z.object({ item: ItemSchema }))
    .errors(CommonPluginErrors),

  // Server-side streaming
  search: oc
    .route({ method: 'GET', path: '/search' })
    .input(z.object({
      query: z.string(),
      limit: z.number().default(10)
    }))
    .output(eventIterator(z.object({
      item: ItemSchema,
      score: z.number()
    })))
    .errors(CommonPluginErrors),

  // Health check
  ping: oc
    .route({ method: 'GET', path: '/ping' })
    .output(z.object({ 
      status: z.literal('ok'),
      timestamp: z.string() 
    }))
    .errors(CommonPluginErrors),
});
```

**Key Concepts:**
- Use `z.object()` for complex types
- Use `eventIterator()` for streaming procedures
- Always include `.errors(CommonPluginErrors)` for standard error handling
- Define meaningful HTTP methods and paths

### Step 2: Create Your Service (service.ts)

The service wraps your external API using a plain TypeScript class with Effect error handling:

```typescript
import { Effect } from "every-plugin/effect";
import { z } from "every-plugin/zod";
import type { ItemSchema } from "./contract";

type Item = z.infer<typeof ItemSchema>;

/**
 * Service that wraps your external API with Effect-based error handling.
 */
export class YourService {
  constructor(
    private readonly baseUrl: string,
    private readonly apiKey: string,
    private readonly timeout: number
  ) {}

  getById(id: string) {
    return Effect.tryPromise({
      try: async () => {
        const response = await fetch(`${this.baseUrl}/items/${id}`, {
          headers: { Authorization: `Bearer ${this.apiKey}` },
          signal: AbortSignal.timeout(this.timeout)
        });
        
        if (!response.ok) {
          throw new Error(`Item ${id} not found`);
        }
        
        const data = await response.json();
        return {
          id: data.id,
          title: data.title,
          createdAt: new Date(data.created_at).toISOString(),
        } satisfies Item;
      },
      catch: (error: unknown) => 
        new Error(`Failed to fetch item: ${error instanceof Error ? error.message : String(error)}`)
    });
  }

  search(query: string, limit: number) {
    return Effect.gen(function* () {
      // Mock streaming search results  
      const generator: AsyncGenerator<{ item: Item; score: number }> = (async function* () {
        for (let i = 0; i < limit; i++) {
          yield {
            item: {
              id: `${query}-${i}`,
              title: `${query} result ${i + 1}`,
              createdAt: new Date().toISOString(),
            },
            score: Math.max(0.1, 1 - i * 0.1),
          };
        }
      })();
      
      return generator;
    });
  }

  ping() {
    return Effect.tryPromise({
      try: async () => {
        await fetch(`${this.baseUrl}/health`);
        return {
          status: "ok" as const,
          timestamp: new Date().toISOString()
        };
      },
      catch: (error: unknown) => 
        new Error(`Health check failed: ${error instanceof Error ? error.message : String(error)}`)
    });
  }
}
```

**Key Concepts:**
- Plain class with constructor accepting config values
- Use `Effect.tryPromise` to wrap async operations
- Use `Effect.gen` for complex flows with multiple steps  
- Return `AsyncGenerator` for streaming data
- Always type `catch` parameter as `unknown` and handle safely
- Use `satisfies` to ensure type safety

### Step 3: Create the Plugin (index.ts)

Wire everything together using `createPlugin`:

```typescript
import { createPlugin } from "every-plugin";
import { Effect } from "every-plugin/effect";
import { implement } from "every-plugin/orpc";
import { z } from "every-plugin/zod";
import { contract } from "./contract";
import { YourService } from "./service";

export default createPlugin({
  id: "@your-org/your-plugin",
  
  variables: z.object({
    baseUrl: z.string().url(),
    timeout: z.number().default(10000),
  }),
  
  secrets: z.object({
    apiKey: z.string(),
  }),
  
  contract,
  
  initialize: (config) =>
    Effect.gen(function* () {
      // Create service instance with config
      const service = new YourService(
        config.variables.baseUrl,
        config.secrets.apiKey,
        config.variables.timeout
      );
      
      // Test the connection
      yield* service.ping();
      
      return { service };
    }),
  
  shutdown: () => Effect.void,
  
  createRouter: (context, builder) => {
    const { service } = context;
    // builder is already: implement(contract).$context<TContext>()

    return {
      getById: builder.getById.handler(async ({ input }) => {
        const item = await Effect.runPromise(service.getById(input.id));
        return { item };
      }),

      search: builder.search.handler(async function* ({ input }) {
        const generator = await Effect.runPromise(
          service.search(input.query, input.limit)
        );

        for await (const result of generator) {
          yield result;
        }
      }),

      ping: builder.ping.handler(async () => {
        return await Effect.runPromise(service.ping());
      }),
    };
  }
});
```

**Key Concepts:**
- Use `Effect.gen` with `yield*` in initialize
- Create service with `new YourService(config...)`
- Return a context object from initialize
- Use `Effect.runPromise` to execute Effects in handlers
- Streaming handlers use `async function*` and `yield` items

## Advanced Patterns

The template keeps things simple. Here are patterns you can add when needed:

### Background Processing Patterns

Plugins often need to continuously process data or broadcast events to multiple clients. Here are the two main approaches:

#### Event Broadcasting with MemoryPublisher (Default for Streaming)

**When to Use**: Broadcasting events to multiple consumers (pub/sub), streaming to HTTP clients, serverless compatibility.

MemoryPublisher provides **broadcast semantics** - all subscribers receive the same events. This is the correct pattern for plugins that mount onto HTTP servers where multiple clients stream data from the same plugin instance.

```typescript
import { Effect } from "every-plugin/effect";
import { MemoryPublisher } from "every-plugin/orpc";

// Define event channels and their payloads
type BackgroundEvents = {
  'background-updates': {
    id: string;
    index: number;
    timestamp: number;
  };
};

// In initialize
initialize: (config) =>
  Effect.gen(function* () {
    const service = new YourService(/* ... */);

    // Create publisher for broadcasting events (scoped resource)
    const publisher = new MemoryPublisher<BackgroundEvents>({
      resumeRetentionSeconds: 60 * 2, // Retain events for 2 minutes to support resume
    });

    // Start background producer (auto-cleanup with forkScoped)
    yield* Effect.forkScoped(
      Effect.gen(function* () {
        let i = 0;
        while (true) {
          i++;
          // Poll external API or generate events
          const event = {
            id: `bg-${i}`,
            index: i,
            timestamp: Date.now(),
          };

          // Publish to all subscribers
          yield* Effect.tryPromise(() =>
            publisher.publish('background-updates', event)
          ).pipe(
            Effect.catchAll((error) => {
              console.log(`Publish failed for event ${i}:`, error);
              return Effect.void;
            })
          );

          // Wait before next poll
          yield* Effect.sleep("30 seconds");
        }
      })
    );

    return { service, publisher };
  }),

// In createRouter - subscribe to broadcast stream
createRouter: (context, builder) => {
  const { service, publisher } = context;

  return {
    // ... other handlers

    // Background streaming with resume support and event metadata access
    listenBackground: builder.listenBackground.handler(async function* ({
      input,
      signal,
      lastEventId
    }) {
      let count = 0;
      const maxResults = input.maxResults;
      const iterator = publisher.subscribe('background-updates', {
        signal,
        lastEventId
      });

      for await (const event of iterator) {
        if (maxResults && count >= maxResults) break;

        // Optional: Access SSE metadata with getEventMeta(event)
        // Provides: { id: string, retry: number, comments: string[] }

        yield event;
        count++;
      }
    }),

    // Manual event publishing endpoint
    enqueueBackground: builder.enqueueBackground.handler(async ({ input }) => {
      const event = {
        id: input.id || `manual-${Date.now()}`,
        index: -1,
        timestamp: Date.now(),
      };

      await publisher.publish('background-updates', event);
      return { ok: true };
    })
  };
}
```

**Key Benefits of MemoryPublisher:**
- **Broadcast Semantics**: All connected clients get the same events
- **Serverless Resume**: `lastEventId` + `resumeRetentionSeconds` support reconnection after timeouts
- **Effect Integration**: Uses `Effect.acquireRelease` for lifecycle management
- **Distributed Ready**: Drop-in replacement with Redis publishers for multi-instance scaling

**Scaling to Redis:**
```typescript
// Development: MemoryPublisher (single instance)
import { MemoryPublisher } from 'every-plugin/orpc';
const publisher = new MemoryPublisher<Events>({ resumeRetentionSeconds: 120 });

// Production: IORedisPublisher (multi-instance)
import { IORedisPublisher } from 'every-plugin/orpc';
import Redis from 'ioredis';
const redis = new Redis(process.env.REDIS_URL);
const publisher = new IORedisPublisher<Events>(redis, {
  resumeRetentionSeconds: 120,
  namespace: 'my-plugin'
});
```

#### Work Distribution with Queues (Alternative Pattern)

**When to Use**: Work distribution where each task is consumed by exactly one worker, job processing, scheduled tasks.

Queue provides **work distribution semantics** - each item added to the queue gets consumed by one worker. Use this for background task processing, not for streaming to multiple clients.

```typescript
import { Effect, Queue } from "every-plugin/effect";

// In initialize
initialize: (config) =>
  Effect.gen(function* () {
    const service = new YourService(/* ... */);

    // Create queue for work distribution (scoped resource)
    const queue = yield* Effect.acquireRelease(
      Queue.bounded(1000),
      (q) => Queue.shutdown(q)
    );

    // Start background worker (one consumer)
    yield* Effect.forkScoped(
      Effect.gen(function* () {
        while (true) {
          // Take one item from queue (work distribution)
          const task = yield* Queue.take(queue);

          // Process task (exactly once semantics)
          yield* service.processTask(task);

          yield* Effect.yieldNow(); // Allow interruption
        }
      })
    );

    return { service, queue };
  }),

// In createRouter - enqueue work, not streaming
const enqueueTask = builder.enqueueTask.handler(async ({ input }) => {
  await Effect.runPromise(Queue.offer(context.queue, input.task));
  return { queued: true };
});
```

**Key Differences:**
- **MemoryPublisher**: Broadcast all events to all subscribers (streaming pub/sub)
- **Queue**: Distribute work - each item processed by one worker (job processing)

**Important:**
- Use `Effect.acquireRelease` for queue cleanup
- Use `Effect.forkScoped` for background tasks (ensures cleanup)
- Scoped resources are automatically cleaned up on shutdown

### Error Handling

Transform external errors to CommonPluginErrors:

```typescript
import { PluginConfigurationError } from "every-plugin";

getById(id: string) {
  return Effect.tryPromise({
    try: async () => {
      const response = await fetch(`${this.baseUrl}/items/${id}`);
      
      if (response.status === 401) {
        throw new PluginConfigurationError({
          message: "Invalid API credentials",
          retryable: false
        });
      }
      
      if (response.status === 429) {
        throw new Error("Rate limited");
      }
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }
      
      return await response.json();
    },
    catch: (error: unknown) => {
      // Re-throw configuration errors
      if (error instanceof PluginConfigurationError) throw error;
      return new Error(`Fetch failed: ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

// In createRouter - map to CommonPluginErrors
const getById = builder.getById.handler(async ({ input, errors }) => {
  try {
    const item = await Effect.runPromise(service.getById(input.id));
    return { item };
  } catch (error) {
    if (error instanceof PluginConfigurationError) {
      throw errors.UNAUTHORIZED({
        message: error.message,
        data: { apiKeyProvided: true }
      });
    }

    if (error instanceof Error && error.message.includes('Rate limited')) {
      throw errors.RATE_LIMITED({
        message: "API rate limit exceeded",
        data: { retryAfter: 60, limitType: 'requests' as const }
      });
    }

    throw errors.SERVICE_UNAVAILABLE({
      message: error instanceof Error ? error.message : 'Unknown error',
      data: { retryAfter: 30 }
    });
  }
});
```

### Pagination with Streaming

For APIs with cursor-based pagination:

```typescript
search(params: { query: string; limit: number; cursor?: string }) {
  return Effect.gen(function* () {
    const generator: AsyncGenerator<SearchResult> = (async function* () {
      let cursor = params.cursor;
      let fetched = 0;
      
      while (fetched < params.limit) {
        const response = await fetch(
          `${this.baseUrl}/search?q=${params.query}&cursor=${cursor || ''}`
        );
        const data = await response.json();
        
        for (const item of data.items) {
          if (fetched >= params.limit) break;
          yield transformItem(item);
          fetched++;
        }
        
        if (!data.next_cursor) break;
        cursor = data.next_cursor;
      }
    })();
    
    return generator;
  });
}
```

### Webhook Mode

For plugins that can operate via webhooks:

```typescript
// In contract.ts
webhook: oc
  .route({ method: 'POST', path: '/webhook' })
  .input(WebhookPayloadSchema)
  .output(z.object({ processed: z.boolean() }))
  .errors(CommonPluginErrors),

// In initialize - create queue for webhook events
const webhookQueue = yield* Effect.acquireRelease(
  Queue.bounded(1000),
  (q) => Queue.shutdown(q)
);

// In createRouter
const webhook = builder.webhook.handler(async ({ input }) => {
  await Effect.runPromise(
    Queue.offer(context.webhookQueue, transformWebhookData(input))
  );
  return { processed: true };
});

const stream = builder.stream.handler(async function* ({ input }) => {
  while (true) {
    const event = await Effect.runPromise(Queue.take(context.webhookQueue));
    yield event;
  }
});
```

## Best Practices

### Type Safety
- Always use `z.infer<typeof Schema>` for types
- Use `satisfies` to check object literals match schemas
- Type `catch` parameters as `unknown` and handle safely

### Resource Management
- Use `Effect.acquireRelease` for resources that need cleanup
- Use `Effect.forkScoped` for background tasks (auto-cleanup)
- Use `Queue.bounded` instead of unbounded queues
- Return context from initialize with all resources

### Error Handling
- Always wrap external calls in `Effect.tryPromise`
- Provide meaningful error messages with context
- Use `CommonPluginErrors` in handlers for standard errors
- Re-throw configuration errors after catching

### Testing
- Use `createLocalPluginRuntime` for testing
- Mock external APIs with MSW or similar
- Test error cases and edge conditions
- Test streaming procedures thoroughly

### Performance
- Use `Promise.all` for parallel operations
- Implement pagination for large result sets
- Add appropriate timeouts to external calls
- Use streaming for large datasets

### Security
- Never log secrets or sensitive data
- Validate all external inputs with Zod schemas
- Use HTTPS for external API calls
- Sanitize error messages
- Use template injection for secrets ({{SECRET_NAME}})

## Quick Reference

### Minimal Plugin Structure

```typescript
// contract.ts
export const contract = oc.router({
  getData: oc.route({ method: 'GET', path: '/data' })
    .input(z.object({ id: z.string() }))
    .output(z.object({ data: DataSchema }))
    .errors(CommonPluginErrors)
});

// service.ts
export class MyService {
  constructor(private apiKey: string, private baseUrl: string) {}
  
  getData(id: string) {
    return Effect.tryPromise({
      try: () => fetch(`${this.baseUrl}/data/${id}`).then(r => r.json()),
      catch: (e: unknown) => new Error(`Failed: ${e}`)
    });
  }
}

// index.ts
export default createPlugin({
  id: "@org/plugin",
  variables: z.object({ apiUrl: z.string() }),
  secrets: z.object({ apiKey: z.string() }),
  contract,
  initialize: (config) => Effect.gen(function* () {
    const service = new MyService(config.secrets.apiKey, config.variables.apiUrl);
    return { service };
  }),
  shutdown: () => Effect.void,
  createRouter: (ctx, builder) => {
    // builder is already: implement(contract).$context<TContext>()
    return {
      getData: builder.getData.handler(async ({ input }) => {
        const data = await Effect.runPromise(ctx.service.getData(input.id));
        return { data };
      })
    };
  }
});
```

## Documentation & Deployment

After building your plugin, document it well and deploy it so others can use it.

### Writing Good READMEs

Your plugin should have a user-friendly README and the technical LLM.txt (this file) for builders.

**README.md Structure:**
- **Title and Description** - What your plugin does, who it's for
- **Installation** - How to add to registry
- **Usage Examples** - Copy-paste ready code for common use cases
- **Configuration** - What variables/secrets are needed
- **Link to LLM.txt** - Point developers to this detailed guide

Example README structure:
```markdown
# My Plugin

A plugin for connecting to [External Service] APIs.

## Installation

Add to your registry:
```javascript
const registry = {
  "my-org/my-plugin": {
    remoteUrl: "https://cdn.example.com/plugins/my-plugin/remoteEntry.js",
    version: "1.0.0"
  }
};
```

## Usage

```typescript
const { client } = await runtime.usePlugin("my-org/my-plugin", {
  variables: { apiUrl: "https://api.external.com" },
  secrets: { apiKey: "{{API_KEY}}" }
});

// Single query
const data = await client.getData({ id: "123" });

// Streaming
for await (const item of client.streamData({ query: "search" })) {
  console.log(item);
}
```

## Configuration

Required secrets:
- `API_KEY` - Your external service API key

Optional variables:
- `timeout` - Request timeout in milliseconds (default: 10000)

---

**For developers building integrations, see [LLM.txt](./LLM.txt).**
```

### Build Process

Use the included rspack config for Module Federation builds:

```bash
# Development server with hot reload
npm run dev         # Serves at http://localhost:3014

# Production build
npm run build       # Creates dist/ with remoteEntry.js
```

The build config handles:
- **Module Federation** - Shares dependencies to reduce bundle size
- **Zephyr Integration** - For easy CDN deployment
- **Source Maps** - For debugging remote plugins

### Registry Configuration

Deploy and register your plugin for others to use.

**Local Development Registry:**
For testing during development - no deployment needed:

```typescript
import { createLocalPluginRuntime } from "every-plugin/runtime";
import MyPlugin from "./src/index";

const runtime = createLocalPluginRuntime(
  { registry: {} },  // Empty registry - plugins loaded locally
  { "my-plugin": MyPlugin }  // Direct import, same API
);
```

**Remote Production Registry:**
Deploy to a CDN/hosting service, then register:

```javascript
// Method 1: Localhost for testing
const runtime = createPluginRuntime({
  registry: {
    "my-org/my-plugin": {
      remoteUrl: "http://localhost:3014/remoteEntry.js",  // From dev server
      version: "1.0.0"
    }
  }
});

// Method 2: Remote CDN (after deployment)
const runtime = createPluginRuntime({
  registry: {
    "my-org/my-plugin": {
      remoteUrl: "https://cdn.zephyr.com/v123/plugins/my-plugin/remoteEntry.js",
      version: "1.0.0"
    }
  }
});

// Same usage API for both!
const { client } = await runtime.usePlugin("my-org/my-plugin", {
  variables: { timeout: 30000 },
  secrets: { apiKey: "{{PROD_API_KEY}}" }  // Template injection
});
```

**Deployment Options:**
1. **Zephyr** - Automatic CDN deployment (`npm run deploy`)
2. **Manual Upload** - Build then upload `dist/remoteEntry.js` to CDN
3. **Self-hosted** - Serve from your own infrastructure

Once deployed, share the `remoteUrl` so others can add to their registries.

## Common Pitfalls

1. **Don't return raw Effects from handlers** - use `Effect.runPromise`
2. **Use async function* for streaming** - not generators that return Effects
3. **Type catch parameters as unknown** - then check instanceof Error
4. **Use yield* in Effect.gen** - not regular yield
5. **Return context from initialize** - don't store globally
6. **Use Effect.forkScoped for background tasks** - ensures cleanup
7. **Use Effect.acquireRelease for resources** - ensures cleanup on shutdown

## Next Steps

1. Copy the template to your new plugin directory
2. Update `contract.ts` with your API procedures
3. Implement `service.ts` with your external API client
4. Wire everything in `index.ts`
5. Add tests in `__tests__/`
6. Update `package.json` with dependencies
7. Build with `npm run build`
8. Test with `createLocalPluginRuntime`

## Related Examples

- **[telegram](../telegram/)** - Webhook + polling modes, background processing
- **[gopher-ai](../gopher-ai/)** - LLM API integration  
- **[test-plugin](../../packages/core/__tests__/test-plugin/)** - Testing patterns
- **[patterns.mdx](../../apps/docs/content/docs/plugins/patterns.mdx)** - More patterns and examples
