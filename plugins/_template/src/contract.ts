import { CommonPluginErrors } from "every-plugin";
import { eventIterator, oc } from "every-plugin/orpc";
import { z } from "every-plugin/zod";

// Schema for the data items this plugin provides
export const ItemSchema = z.object({
  id: z.string().describe("Unique identifier for the item"),
  title: z.string().describe("Title or name of the item"),
  createdAt: z.string().datetime().describe("ISO 8601 timestamp when the item was created"),
});

// Schema for search results
export const SearchResultSchema = z.object({
  item: ItemSchema,
  score: z.number().min(0).max(1).describe("Relevance score between 0 and 1"),
});

// Schema for background broadcast events (MemoryPublisher)
export const BackgroundEventSchema = z.object({
  id: z.string().describe("Unique identifier for the background event"),
  index: z.number().describe("Sequential index of the event"),
  timestamp: z.number().describe("Unix timestamp in milliseconds when the event was created"),
});

// oRPC Contract definition
export const contract = oc.router({
  // Single item lookup by ID
  getById: oc
    .route({
      method: 'GET',
      path: '/items/{id}',
      summary: 'Get item by ID',
      description: 'Fetches a single item by its unique identifier. This is the primary method for retrieving individual items.',
      tags: ['Items'],
    })
    .input(z.object({
      id: z.string().min(1, "ID is required").describe('Unique item identifier'),
    }))
    .output(z.object({
      item: ItemSchema,
    }))
    .errors(CommonPluginErrors),

  // Search with server-side streaming
  search: oc
    .route({
      method: 'GET',
      path: '/search',
      summary: 'Search items',
      description: 'Performs a search across items with server-side streaming. Returns results as they become available for better performance.',
      tags: ['Items', 'Search'],
    })
    .input(z.object({
      query: z.string().min(1, "Query is required").describe('Search query string'),
      limit: z.number().min(1).max(100).default(10).describe('Maximum number of results to return'),
    }))
    .output(eventIterator(SearchResultSchema)) // Notice "eventIterator", this enables streaming
    .errors(CommonPluginErrors),

  // Health check procedure
  ping: oc
    .route({
      method: 'GET',
      path: '/ping',
      summary: 'Health check',
      description: 'Simple ping endpoint to verify the plugin is responding correctly.',
      tags: ['Health'],
    })
    .output(z.object({
      status: z.literal('ok').describe('Always returns "ok" if the service is healthy'),
      timestamp: z.string().datetime().describe('ISO 8601 timestamp of when the ping was processed'),
    }))
    .errors(CommonPluginErrors),

  // Background streaming with resume support (MemoryPublisher)
  listenBackground: oc
    .route({
      method: 'GET',
      path: '/background/events',
      summary: 'Listen to background events',
      description: 'Streams background events generated by the plugin. Supports resume from last event ID for serverless environments.',
      tags: ['Streaming', 'Background'],
    })
    .input(z.object({
      maxResults: z.number().min(1).max(100).optional().describe('Maximum number of events to return'),
      lastEventId: z.string().optional().describe('Resume from this event ID (for serverless resume)'),
    }))
    .output(eventIterator(BackgroundEventSchema))
    .errors(CommonPluginErrors),

  // Manual background event publishing
  enqueueBackground: oc
    .route({
      method: 'POST',
      path: '/background/events',
      summary: 'Enqueue background event',
      description: 'Manually adds an event to the background stream. Useful for testing event broadcasting.',
      tags: ['Background', 'Testing'],
    })
    .input(z.object({
      id: z.string().optional().describe('Optional custom event ID'),
    }))
    .output(z.object({
      ok: z.boolean().describe('True if the event was successfully enqueued'),
    }))
    .errors(CommonPluginErrors),
});
